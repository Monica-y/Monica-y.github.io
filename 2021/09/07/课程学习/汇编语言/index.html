<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"monica-y.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="汇编语言学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言">
<meta property="og:url" content="https://monica-y.github.io/2021/09/07/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="汇编语言学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%B1%87%E7%BC%9635_%E4%B8%A4%E5%AD%97%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%8A%A0.png">
<meta property="article:published_time" content="2021-09-07T11:02:50.207Z">
<meta property="article:modified_time" content="2021-10-12T13:19:47.528Z">
<meta property="article:author" content="Monica">
<meta property="article:tag" content="汇编语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://monica-y.github.io/images/%E6%B1%87%E7%BC%9635_%E4%B8%A4%E5%AD%97%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%8A%A0.png">

<link rel="canonical" href="https://monica-y.github.io/2021/09/07/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>汇编语言 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://monica-y.github.io/2021/09/07/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Monica">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          汇编语言
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-07 19:02:50" itemprop="dateCreated datePublished" datetime="2021-09-07T19:02:50+08:00">2021-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-12 21:19:47" itemprop="dateModified" datetime="2021-10-12T21:19:47+08:00">2021-10-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机组成与系统结构</span></a>
                </span>
            </span>

          
            <div class="post-description">汇编语言学习笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>1、指令系统：CPU能识别的所有指令的集合。<br>2、机器语言：指令代码语言。<br>3、机器语言程序：用机器语言编写的程序。<br>4、汇编语言：符号化语言。<br>5、汇编语言（源）程序：用汇编语言编写的程序。<br>6、汇编：将汇编语言源程序翻译成机器语言的过程。<br>7、反汇编:将机器语言程序翻译成汇编语言程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,12H  //BO 12</span><br><span class="line">ADD AL,21H  //04 21</span><br><span class="line">PUSH AX     //50</span><br><span class="line">MOV BL,FFH  //B3 FF</span><br><span class="line">AND BL,AL   //20 C3</span><br><span class="line">POP AX      //58</span><br></pre></td></tr></table></figure>
<p>//后为汇编后的结果。<br>文件名.ASM-&gt;文件名.OBJ(目标码文件)。<br>连接 Link.exe程序生成.exe文件</p>
<h2 id="8086汇编语言程序中语句的种类"><a href="#8086汇编语言程序中语句的种类" class="headerlink" title="8086汇编语言程序中语句的种类"></a>8086汇编语言程序中语句的种类</h2><p>1、指令语句：CPU能执行的语句。汇编后能翻译成二进制指令代码的语句。<br>2、伪指令语句：CPU不能执行的语句。汇编后不能翻译成二进制指令代码的语句。如DB、DW。<br>3、宏指令语句:本身是8086指令系统没有的指令。是用户用宏定义伪指令定义的一条新语句。</p>
<h2 id="汇编语言中语句的组成"><a href="#汇编语言中语句的组成" class="headerlink" title="汇编语言中语句的组成"></a>汇编语言中语句的组成</h2><p>名称、助记符、操作数、注释<br>注意：凡是数字，必须以0~9开头，凡是名称，必须以字母开头。<br>如：DB,means data byte，所定义的数据类型为一个字节宽度。<br>DW，means data word，所定义的数据类型为两个字节。<br>DD，means data double word，所定义的数据类型为四个字节。<br>变量名<br>标号名—next:(冒号不能少)</p>
<h2 id="汇编语言程序设计中用到的常数及表达式"><a href="#汇编语言程序设计中用到的常数及表达式" class="headerlink" title="汇编语言程序设计中用到的常数及表达式"></a>汇编语言程序设计中用到的常数及表达式</h2><p>1、二进制常数以大写B结尾。<br>2、十进制常数D缺省。<br>3、十六进制常数以大写H结尾。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MOV DL,<span class="string">'A'</span>//A的阿思科码常数</span><br><span class="line">STRING DB <span class="string">'an apple'</span>//字符串常数</span><br><span class="line"></span><br><span class="line">/*表达式*/</span><br><span class="line">MOV AL,5+2*3//汇编时会先计算表达式的值</span><br><span class="line">AND AL,21H AND 0FH</span><br><span class="line">MOV AX,5 LT 3//LT为＜，为真取全一，为假取全零</span><br></pre></td></tr></table></figure>
<h2 id="标号、变量及伪指令"><a href="#标号、变量及伪指令" class="headerlink" title="标号、变量及伪指令"></a>标号、变量及伪指令</h2><h3 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NEXT:.......</span><br><span class="line">JZ NEXT</span><br></pre></td></tr></table></figure>
<p>1、标号一旦定义了，就具有三个属性：NEXT所在存储单元的段地址属性(SEG)；段内偏移地址属性(OFFSET)较常用；类型(TYPE)分为NEAR和FAR两种类型。<br>NEAR—近程— -1（在同一个代码段内跳转）<br>FAR—远程— -2（不在同一个代码段内跳转）</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>1、DB：定义字节型变量1<br>2、DW：定义字型变量2<br>3、DD：定义双字型变量4<br>例：在DS段有以下变量定义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAT1 DB 12,12H,-12,<span class="string">'1'</span></span><br></pre></td></tr></table></figure>
<p>变量一旦定义了，就具有了五个属性：<br>1、段地址属性；SEG<br>2、段内偏移地址（有效地址）属性；OFFSET<br>3、类型的属性；（值为变量所占的字节数）TYPE<br>4、长度属性；LENGTH<br>5、大小属性。SIZE</p>
<p>获取DAT1的类型<br>如：MOV AL,TYPE DAT1<br>等效于：MOV AL,1</p>
<p>获取DAT1的段内偏移<br>MOV BX,OFFSET DAT1<br>BX是地址寄存器，才有进一步寻址的意义，否则给AX寄存器语法无误，但是没有现实意义。</p>
<p>一个逻辑段的地址，没有特别说明，段内偏移地址为0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAT2 DW $+2,56ACH,78H</span><br></pre></td></tr></table></figure>
<p>在MASM.exe中有一个$位，叫做位置计数器（16位），表示汇编程序汇编到的位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DAT3 DB <span class="string">'THIS'</span></span><br><span class="line">DAT4 DW <span class="string">'AB'</span>,<span class="string">'C'</span>//小端存储</span><br><span class="line">//以DB或是DW定义的字符串，一个单引号里面最多只能有两个字符串，如果只放一个，则DB不能超过64k，否则逻辑段放不下。（段内编译为16位，最大为64KB）</span><br><span class="line">DAT5 DD 9CH//4个字节</span><br><span class="line">DAT6 DW DAT3//DAT6位置存放的是DAT3的字型属性--段内偏移</span><br><span class="line">DAT7 DD DAT3//四个字节存放的是DAT3的双字属性--段地址属性，存放的是1500：000A，因此四个字节依次存放的是0A，00，00，15。</span><br><span class="line">DAT8 DB 4 DUP(?)//DUP重复操作符</span><br><span class="line">DAT9 DW 3 DUP(?)</span><br><span class="line">buf2 DB 7 DUP(5 DUP(55H),10 DUP(240))</span><br></pre></td></tr></table></figure>
<p>长度：在变量名定义语句中，所定义的变量的个数。有DUP语句时，数字参数就是变量数，没有DUP的语句就是定义了一个变量。</p>
<p>大小：在变量名定义语句中，所定义的所有变量所占的总的字节数叫做该变量的大小。DAT9占了6个字节，则其大小为6个字节。</p>
<script type="math/tex; mode=display">SIZE = TYPE \times LENGTH</script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,DAT1+2//</span><br><span class="line">MOV AX,DAT1//语法错误，无法汇编，需要强制类型转换</span><br><span class="line">MOV AX,WORD PTR DAT1//AX = 120CH//DAT1仍然是字节变量，属性临时修改操作符</span><br><span class="line">MOV [BX],10H//语法错误</span><br><span class="line">MOV BYTE PTR[BX],10H//bingo</span><br></pre></td></tr></table></figure>
<h2 id="指令的分类"><a href="#指令的分类" class="headerlink" title="指令的分类"></a>指令的分类</h2><p>1、数据传送类指令。MOV。<br>2、算术运算类。加减乘除<br>3、逻辑运算指令。与、或、抑或、非<br>4、移位类<br>5、标志位操作指令<br>6、转移类指令。条件转移指令、无条件转移指令、子程序调用指令。<br>7、循环控制指令。LOOP<br>8、子程序调用与返回指令。call<br>9、中断调用返回指令。<br>10、字符串操作类指令。<br>11、输入输出指令。<br>12、其他指令。<br>13、宏指令。</p>
<p>目的操作数DST<br>操作数OPR</p>
<h2 id="数据与转移地址的寻址方式"><a href="#数据与转移地址的寻址方式" class="headerlink" title="数据与转移地址的寻址方式"></a>数据与转移地址的寻址方式</h2><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>寻址方式就是求操作数所在地或者算在存储器单元地址的方式。</p>
<p>求得的操作数OPR可以作为操作或运算的数据用，或者用作实现转移的转移地址用。（段内转移求偏移地址给IP，段间转移还要求得目的地的段地址给CS）。</p>
<h3 id="关于寻找数据的寻址方式"><a href="#关于寻找数据的寻址方式" class="headerlink" title="关于寻找数据的寻址方式"></a>关于寻找数据的寻址方式</h3><p>1、立即数寻址。要寻找的操作数指令中给出了，如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,1234H//目的操作数，源操作数（立即数寻址）</span><br></pre></td></tr></table></figure>
<p>说明立即数只能做源操作数。</p>
<p>2、寄存器寻址。要寻找的操作数在某寄存器中。如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,BX//源操作数的寻址方式是寄存器寻址</span><br><span class="line">MOV AX,CL//源和目的的操作类型不一致</span><br></pre></td></tr></table></figure>
<p>当源操作数和目的操作数都是寄存器寻址时，要注意类型要一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV [0200H],56H//[]里是个地址，DS:0200H,立即数没有类型，该指令语法错误</span><br><span class="line">MOV WORD PTR[0200H],56H</span><br></pre></td></tr></table></figure>
<p>在书写指令时，要注意类型要明确。源和目的操作数只要有一方明确，则类型明确。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DS,1500H//error!</span><br><span class="line">MOV AX,1500H</span><br><span class="line">MOV DS,AX</span><br></pre></td></tr></table></figure>
<p>在给段地址寄存器(DS\ES\SS)赋值时，需要通过中间的通用寄存器。<br>当DS、ES、SS做目的操作数时，源操作数不能为立即数或立即数寻址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV CX,AX</span><br></pre></td></tr></table></figure>
<p>CX\IP不能做目的操作数。只能通过执行转移指令操作数改变CX和IP内的值。（IP指令指针寄存器）。<br>堆栈必须按照字操作。</p>
<p>3、存储器寻址。要寻找的操作数OPR在存储器某单元中。存储操作数的单元的EA（段内偏移地址）可以由以下五种寻址方式求得：<br>（一）直接寻址。在指令中直接写出操作数所在单元的地址。<br>（二）寄存器间接寻址。寄存器有基址寄存器BX、源变址寄存器SI、目的变址寄存器DI，形式如[SI]。<br>（三）寄存器相对寻址。基址寄存器BX、基址指针寄存器BP、源变址寄存器SI、目的变址寄存器DI，这四者之一加上一个8/16位的disp（相对位移量），两部分之和就是操作数所在存储单元的地址。<br>（四）基址、变址寻址。基址[BX],[BP]。变址寄存器[SI],[DI]。<br>（五）基址、变址且相对寻址。基址寄存器+变址寄存器+相对位移量。</p>
<h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>操作数所在单元的有效地址指令中直接给出了。如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AL [2000H]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//DS段</span><br><span class="line">data1 DB 12H</span><br><span class="line">data2 DB 34H</span><br><span class="line">//CS段</span><br><span class="line">MOV AL ,data1//目的操作数寄存器寻址，源操作数是直接寻址</span><br><span class="line">//(AL)= 12H;</span><br><span class="line"></span><br><span class="line">MOV data2,data1;//error!</span><br><span class="line">//上面error语句可以修改为</span><br><span class="line">MOV AL,data1</span><br><span class="line">MOV data2,AL</span><br><span class="line"></span><br><span class="line">MOV data1,AX//error!类型不一致</span><br><span class="line">MOV WORD PTR data1,AX//只是在本行语句种起作用，对data1的类型进行临时修改，在之后的编程中，data1的类型依然为字节型。</span><br></pre></td></tr></table></figure>
<p>两存储器单元之间不能直接操作。</p>
<h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>段内偏移只可能存储在寄存器[BX],[SI],[DI]中。段地址位于[DS]中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data1 DB 12H</span><br><span class="line">data2 DB 34H</span><br><span class="line"></span><br><span class="line">//把data1对应数据移动到AL</span><br><span class="line">MOV BX,offset data1</span><br><span class="line">//源操作数为立即数寻址，变量一旦定义了，就具有了五个属性，属性是一个常数。</span><br><span class="line">MOV AL,[BX]</span><br><span class="line">//源操作数采用的是寄存器间接寻址</span><br><span class="line"></span><br><span class="line">MOV [BX],56H</span><br><span class="line">//源操作数为立即数寻址，目的操作数为寄存器间接寻址，error，立即数没有类型，故而整个指令类型不确定。</span><br><span class="line"></span><br><span class="line">MOV BX,offset data1</span><br><span class="line">MOV SI,offset data2</span><br><span class="line">MOV [BX],[SI]</span><br><span class="line">//error!两存储器单元之间不能直接传输数据。需要使用一个通用寄存器过渡。</span><br><span class="line">//修改为</span><br><span class="line">MOV AL,[SI]</span><br><span class="line">MOV [BX],AL</span><br></pre></td></tr></table></figure>
<h3 id="寄存器相对寻址"><a href="#寄存器相对寻址" class="headerlink" title="寄存器相对寻址"></a>寄存器相对寻址</h3><p>操作数所在存储单元的段内十六位偏移地址是由两部分相加。第一部分为[BX],[BP],[SI],[DI],第二部分为一个相对位移量disp。</p>
<p>当使用[BX],[SI],[DI]这三个寄存器中的任意一个时，段地址默认为DS寄存器。<br>当使用[BP]寄存器时，段地址默认为SS段。只有在寄存器相对寻址中才出现了BP，在寄存器间接寻址中没有BP参与。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MOV [BP],AL;</span><br><span class="line">//把AL寄存器中的内容写入到一个字节单元中，SS：(BP)+0&lt;-(AL),这样只能是寄存器相对寻址，不能是寄存器间接寻址。</span><br><span class="line"></span><br><span class="line">MOV BX,offset data1;</span><br><span class="line">//把data1单元的偏移地址放到BX寄存器中，以便于下一步讲AL中数据存入到data1下两个存储单元中。</span><br><span class="line">//方法一：</span><br><span class="line">MOV data1+3,AL</span><br><span class="line">//目的操作数采用直接寻址</span><br><span class="line">//方法二</span><br><span class="line">MOV [BX]+3,AL</span><br><span class="line">MOV [BX+3],AL</span><br><span class="line">MOV 3+[BX],AL//+可以缺省</span><br><span class="line">//目的操作数寄存器相对寻址,三种方法等效</span><br><span class="line"></span><br><span class="line">MOV BX,0</span><br><span class="line">MOV AL,00H</span><br><span class="line">MOV data1[BX],AL</span><br><span class="line">//目的操作数为寄存器相对寻址，偏移量disp不是一个常量，而是一个变量，当相对量是一个变量的时候，取变量的十六位offset，相当于缺省+的那种情况。此时十六位有效地址为offset data1+(BX)&lt;-(AL)</span><br><span class="line">此时段地址不能看寄存器了，要看变量，变量在哪里定义的，段地址就在相应的寄存器中。</span><br></pre></td></tr></table></figure>
<p>例：8086型号的CPU执行以下程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUSH AX</span><br><span class="line">PUSH BX</span><br><span class="line">PUSH CX</span><br><span class="line"></span><br><span class="line">//目的是DX&lt;-(AX)，但不能破坏SP指针</span><br><span class="line">//意味着不能执行pop操作。充分利用BP相对寻址段地址在ss寄存器的基本原理</span><br><span class="line">MOV BP,SP//破坏了BP，如果不能破坏BP，需要在前一步增加一条PUSH BP。</span><br><span class="line">MOV DX,[BP+4]//如果源操作数是立即数，则要注意类型要明确</span><br></pre></td></tr></table></figure>
<h3 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h3><p>操作数所在存储单元的段内十六位有效地址由两部分组成。第一部分是在[BX],[BP]基址寄存器中。另一部分在[SI],[DI]变址寄存器中。<br>段内地址所在寄存器以基址寄存器为准，若基址寄存器使用[BX]，则段地址在DS中；若基址寄存器使用[BP]，则段地址在SS中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data1 DB 12H</span><br><span class="line">data2 DB 34H</span><br><span class="line"></span><br><span class="line">MOV BX,offset data1</span><br><span class="line">MOV SI,0</span><br><span class="line">MOV AL,0</span><br><span class="line">MOV CX,10</span><br><span class="line">NEXT:MOV [BX][SI],AL//将data1所在单元清零，循环将data1及以后的是个单元清零</span><br><span class="line">INC SI</span><br><span class="line">LOOP NEXT</span><br></pre></td></tr></table></figure>
<h3 id="基址变址且相对寻址"><a href="#基址变址且相对寻址" class="headerlink" title="基址变址且相对寻址"></a>基址变址且相对寻址</h3><p>操作数所在单元的有效地址由三部分组成。第一部分位于基址寄存器中。第二部分位于变址寄存器中。第三部分为8位/16位的相对位移量。<br>段地址所在寄存器：若偏移量是常数，则以以基址寄存器为准，若基址寄存器使用[BX]，则段地址在DS中；若基址寄存器使用[BP]，则段地址在SS中。若偏移量是变量，段地址所在寄存器需要根据变量的定义位置来确定。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data1 DB 12H</span><br><span class="line">data2 DB 34H</span><br><span class="line"></span><br><span class="line">MOV BX,0</span><br><span class="line">MOV SI,0</span><br><span class="line">MOV AL,0</span><br><span class="line">MOV CX,10</span><br><span class="line">NEXT:MOV data1[BX][SI],AL//将data1所在单元清零，循环将data1及以后的是个单元清零</span><br><span class="line">INC SI</span><br><span class="line">LOOP NEXT</span><br></pre></td></tr></table></figure>
<h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUSH AX</span><br><span class="line">//只指明了源操作数，但是CPU知道目的操作数在哪里,目的操作数为隐含寻址</span><br><span class="line">//具体步骤</span><br><span class="line"></span><br><span class="line">SP&lt;-(SP)-2</span><br><span class="line">(SS:(SP))&lt;-(AX)</span><br><span class="line"></span><br><span class="line">MOV AL,data1+2//直接寻址</span><br><span class="line">MOV AL,data1+data2//error!变量不能在指令语句中运算</span><br></pre></td></tr></table></figure>
<h2 id="关于转移地址的寻址方式"><a href="#关于转移地址的寻址方式" class="headerlink" title="关于转移地址的寻址方式"></a>关于转移地址的寻址方式</h2><p>1、段内转移——只有IP发生了改变<br>1）直接寻址（相对寻址，会加上一个相对位移量）。转移指令中直接给出了转移目的地的地址。以标号的形式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L1:...</span><br><span class="line">JMP L1</span><br></pre></td></tr></table></figure>
<p>指令结构：操作码（一个字节）+ 当前IP位置（下一条指令起始地址）的相对位移量。如果相对位移量在[-128,0]范围内（负向转移），则使用一个字节记录相对位移量。如果相对位移量在[0,32767]范围内（正相转移），则使用两个字节记录相对位移量。因为此时转移位置还没有经过编译，不知道具体的相对位移量是多少，只能全部按照两字节相对位移量处理。当负向转移的相对位移量较大时，也可以考虑使用两个字节来存储相对位移量。<br>当确定正向转移的偏移量不超过127时，为了节省空间，可以使用下面指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JMP SHORT L1</span><br><span class="line">//适用于转移偏移量位于[-128,127]的转移指令</span><br></pre></td></tr></table></figure>
<p>转移到目的地的IP = 当前IP（待执行的下一条指令的首地址）+disp(相对位移量)<br>8086指令系统中所有的条件转移指令，只能在段内转移。且转移范围为[-128,127]字节之间。如果转移地址偏移量超过了这个范围，则需要使用无条件转移指令实现二级跳。<br>8086指令系统中所有的条件转移指令，它的寻址方式是段内相对寻址。<br>例：8086CPU执行JZ L1指令时，IP = 0100H，disp = FDH，这条指令执行以后IP的值为多少呢？<br>当前IP = 0102H，再加上FDH（补码表示的位移量），得出的结果为00FFH。<br>2）段内间接寻址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;DS段</span><br><span class="line">TABLE DW L2//L2是一个标号，即将L2的段内偏移地址存放在TABLE单元，L2为转移目的地址的段内偏移量</span><br><span class="line">;CS段</span><br><span class="line">MOV BX,offset L2</span><br><span class="line">JMP BX;IP&lt;-(BX)</span><br><span class="line">L2:</span><br><span class="line"></span><br><span class="line">//直接寻址指令为 </span><br><span class="line">JMP TABLE</span><br><span class="line">//IP&lt;-(TABLE),TABLE变量为直接寻址</span><br><span class="line"></span><br><span class="line">//间接寻址指令为</span><br><span class="line">MOV BX,offset TABLE</span><br><span class="line">JMP WORD PTR [BX]</span><br><span class="line">//以BX寄存器做间接寻址方式的段内间接寻址</span><br><span class="line"></span><br><span class="line">//基址变址寻址指令为</span><br><span class="line">MOV SI,0</span><br><span class="line">MOV BX,offset TABLE</span><br><span class="line">JMP WORD PTR [BX][SI]</span><br><span class="line">//基址变址寻址方式的段内间接寻址</span><br></pre></td></tr></table></figure>
<p>例：若(AL) = 1,则转到L1；若(AL) = 2,则转到L2；若(AL) = 3，则跳转到L3。转移相对位移量小于127字节。<br>通过观察发现三条跳转指令顺序排列，首地址与AL内数字n的关系为</p>
<script type="math/tex; mode=display">2 \times (n-1)</script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MOV BX,offset TAB</span><br><span class="line">DEC AL//AL内容减一</span><br><span class="line">ADD AL,AL</span><br><span class="line">MOV AH,0;</span><br><span class="line">ADD BX,AX</span><br><span class="line">JMP BX//段内间接寻址</span><br><span class="line">TAB:JMP SHORT L1//段内直接寻址</span><br><span class="line">JMP SHORT L2</span><br><span class="line">JMP SHORT L3</span><br><span class="line">L1:</span><br><span class="line">L2:</span><br><span class="line">L3:</span><br></pre></td></tr></table></figure>
<h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><p>除SAHF、POPF（标志寄存器内指令出栈）指令外，其余传送类指令CPU执行后对6个状态标志均<strong>无影响</strong>。<br>语法规则如下：<br>1、立即数只能做源操作数。<br>2、类型要一致。<br>3、类型要明确。<br>4、当DS、ES、SS这三个段寄存器做目的时，源操作数不能为立即数。<br>CS、IP不能做目的。<br>5、两存储单元不能直接操作。<br>6、在指令语句中，不允许两个变量参加运算。</p>
<h3 id="通用数据数据传送指令"><a href="#通用数据数据传送指令" class="headerlink" title="通用数据数据传送指令"></a>通用数据数据传送指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//把源操作数以某种方式指明的内容传送到目的地去</span><br><span class="line">MOV DST SRC</span><br></pre></td></tr></table></figure>
<p>‘通用’的是指一定能用到。</p>
<h3 id="取有效地址指令LEA"><a href="#取有效地址指令LEA" class="headerlink" title="取有效地址指令LEA"></a>取有效地址指令LEA</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEA REG(16bit),MEM</span><br><span class="line">//MEM为由五种存储器寻址方式之一指明的一个存储单元</span><br><span class="line">//最好把有效地址放到BX、BP、SI、DI中。</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV BX,offset data1</span><br><span class="line">LEA BX,data1</span><br><span class="line">//把data1单元的有效地址给BX，上述两条指令功能相同</span><br><span class="line"></span><br><span class="line">MOV BX,PTR data1</span><br><span class="line">//把data1看成一个字单元的内容传输给BX</span><br></pre></td></tr></table></figure>
<h3 id="取地址指针指令LDS、LES"><a href="#取地址指针指令LDS、LES" class="headerlink" title="取地址指针指令LDS、LES"></a>取地址指针指令LDS、LES</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDS REG(16bit),SRC</span><br><span class="line">//把取回来的地址放到DS</span><br><span class="line">//SRC为使用五种寻址方式指明的一个存储单元，从SRC获得的是一个双字单元，小地址单元（第一个字，存偏移量）给REG，大地址单元（第二个字，存段地址）给DS寄存器。</span><br></pre></td></tr></table></figure>
<p>例：某数X（字）所在存储单元的地址指针已经在POINT双字单元中，将DX&lt;-X。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LDS BX,POINT</span><br><span class="line">//POINT是一个双字变量，第一个字偏移地址给BX，第二个字给DX，则当前地址指针指向X</span><br><span class="line">MOV DX,[BX]</span><br><span class="line">//使得(DX) = X</span><br><span class="line"></span><br><span class="line">//若使用LES指令</span><br><span class="line">LES BX，POINT</span><br><span class="line">MOV DX,ES:[BX]</span><br><span class="line">//注意需要增加段前缀</span><br></pre></td></tr></table></figure>
<h3 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h3><p>LAHF-将标志寄存器flag（PSW）低八位的内容传入AH寄存器。<br>SAHF-将AH寄存器的内容写入标志寄存器的低八位位置。修改了标志寄存器的内容。<br>在8086指令系统中没有专门的使标志寄存器清零或置一的指令，但可以使用堆栈操作改变标志寄存器内容，注意不能使用标志传送指令修改TF寄存器的内容，这是因为TF寄存器位于标志寄存器第八位，属于高八位的范围，而该方式只对低八位有效，所以无法改变。<br>关于标志寄存器的内容，<a href="https://blog.csdn.net/weixin_46013401/article/details/111823010" target="_blank" rel="noopener">点击这里</a></p>
<h3 id="数据交换指令XCHG"><a href="#数据交换指令XCHG" class="headerlink" title="数据交换指令XCHG"></a>数据交换指令XCHG</h3><p>XCHG OST，SRC<br>1、其中OST、SRC均不能为立即数<br>2、所有段寄存器均不能参加交换<br>3、上文中提到的六点语法规则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XCHG AX,BX</span><br><span class="line">XCHG AL,[SI+3]</span><br><span class="line">//SI相对寻址</span><br><span class="line">XCHG DH，DL</span><br><span class="line">XCHG AX，ES</span><br><span class="line">//error，段寄存器不能参与交换</span><br><span class="line">XCHG AX，BL</span><br><span class="line">//error 类型不一致</span><br></pre></td></tr></table></figure>
<h3 id="字节转换指令XLAT"><a href="#字节转换指令XLAT" class="headerlink" title="字节转换指令XLAT"></a>字节转换指令XLAT</h3><p>格式：XLAT(查表)<br>无操作数，源和目的都是隐含寻址<br>功能：AL&lt;-(DS:(BX)+(AL))</p>
<p>例：将0-9及A-FH数字-&gt;对应</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在DS段</span><br><span class="line">TABLE DB 30H,31H,...,39H,41H,...46H</span><br><span class="line"></span><br><span class="line">//在CS段</span><br><span class="line">MOV AL，4</span><br><span class="line">LEA BX,TABLE</span><br><span class="line">//将TABLE的偏移地址给BX</span><br><span class="line">XLAT</span><br><span class="line">//此时AL的值为34H，将4数字转换为对应的字符</span><br></pre></td></tr></table></figure>
<h3 id="堆栈操作指令"><a href="#堆栈操作指令" class="headerlink" title="堆栈操作指令"></a>堆栈操作指令</h3><p>1、PUSH SRC<br>要注意SRC不能为立即数<br>2、PUSH DST<br>3、PUSHF<br>4、POPF<br>以上堆栈操作指令都必修按字操作同时遵守上述六个规格。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POP CS</span><br><span class="line">//error!CS不能做目的操作数</span><br><span class="line">PUSH CL</span><br><span class="line">//error！必须按字操作</span><br><span class="line">PUSH 1234H</span><br><span class="line">//error!必须按字操作</span><br></pre></td></tr></table></figure>
<h2 id="算术运算类指令"><a href="#算术运算类指令" class="headerlink" title="算术运算类指令"></a>算术运算类指令</h2><p>1、CPU只要执行运算类指令，执行结果就会影响状态标志。<br>2、段寄存器不能参加运算。</p>
<h3 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h3><p>1、不带进位位加法<br>ADD DST SRC<br>目的操作数DST&lt;-(DST)+SRC,同时根据和设置六个状态标志。ZF、PF、SF、CF、OF、AF。<br>2、带进位位的加法<br>ADC DST SRC<br>目的操作数DST&lt;-(DST)+SRC+CF,同时根据和设置六个状态标志。<br>3、增一指令<br>INC DST<br>目的操作数DST&lt;-(DST)+1,同时根据结果设置<strong>除CF以外</strong>的五个状态标志。对CF无影响。<br>例：两个字型变量相加代码<br><img src="/images/汇编35_两字型数据相加.png" alt="两字型变量相加"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LEA SI,DVAR</span><br><span class="line">MOV AX,[SI]</span><br><span class="line">ADD AX,[SI]+4</span><br><span class="line">MOV WORD PTR DVARC,AX</span><br><span class="line">MOV AX,[SI]+2</span><br><span class="line">ADC AX,[SI]+6</span><br><span class="line">MOV WORD PTR DVARC+2,AX</span><br></pre></td></tr></table></figure>
<h3 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h3><p>1、不带借位位减法<br>SUB DST，SRC<br>DST&lt;-(DST)-(SRC),并根据结果设置六个状态标志。<br>2、带借位位的减法<br>SBB DST，SRC<br>DST&lt;-(DST)-(SRC)-CF,CF为借位标志，并根据结果设置六个状态标志。<br>只要有一方类型明确了，双方就都明确了。<br>3、减一指令<br>DEC DST<br>DST&lt;-(DST)-1,并根据结果设置除CF以外的状态标志，对CF没影响。<br>例：若(AL) = FFH,CF = 0,则CPU执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INC AL</span><br></pre></td></tr></table></figure>
<p>指令后，(AL) = ?,CF = ?<br>(AL) = 00H，CF = 0。</p>
<p>4、比较指令<br>CMP DST,SRC<br>(DST)-(SRC)，结果不存储，只是根据结果设置六个状态标志。分别为CF、SF、ZF、PF、OF。<br>产生条件，使用比较指令来产生条件。<br>测试条件满足吗？如果满足则转到代码一，如果不满足则转到代码二。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,α</span><br><span class="line">CMP AL，β</span><br></pre></td></tr></table></figure>
<p>根据单个条件：<br>CF-JC(有借位则转移)+标号—段内直接寻址、JNC(没有解位则转移)<br>SF-JS(结果为负则转移)+标号、JNS(结果不为负则转移)<br>ZF-JZ/JE(结果为0则转移)+标号、JNZ/JNE(结果不为零则转移)<br>PF-JP(结果低八位1的个数为偶数则转移)+标号、JNP(结果低八位1的个数不为偶数则转移)<br>OF-JO(结果溢出则转移)+标号、JNO(结果未溢出则转移)</p>
<p>若α、β为<strong>无符号数</strong>，则不存在大小的关系，只存在高低的关系。（相等、高、低）。CF<br>高 JA/JNBE<br>低 JB/JNAE(不高于也不等于)<br>相等JE<br>不相等JNE<br>小于等于 JBE/JNA<br>大于等于 JAE/JNB</p>
<p>若α、β为<strong>有符号数</strong>，则存在大小的关系。（相等、大、小）。SF XOR OF = 1,目的小于源<br>大：JG/JNLE<br>小：JL/JNGE<br>小于等于：JLE/JNG<br>大于等于：JGE/JNL</p>
<p>所以，在编写程序时首先要明确参与运算的数据是有符号的还是无符号的。</p>
<p>5、求负指令<br>NEG DST<br>DST&lt;-0-(DST),并根据结果设置六个状态标志。<br>例子：在存储器BUFFER单元有一个16位的带符号数，求该数的绝对值，并把结果放回原数。<br>1、分析题目-提出解决问题的算法。<br>当x≥0时，它的绝对值是它本身。<br>当x＜0时，它的绝对值是它的相反数。<br>2、画出程序流程。<br>开始框和结束框必须用椭圆框。矩形框是处理框。<br>两数比较（x和0比较），使用SF条件，如果SF = 1，则x小于零，对x求负，结果存入BUFFER单元；如果SF！=1，则x不为负，可以直接结束程序。<br>3、编写程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义DS段,data word,DW类型为字型变量</span><br><span class="line">BUFFER DW ?</span><br><span class="line"></span><br><span class="line">//定义代码段</span><br><span class="line">START:MOV AX,BUFFER</span><br><span class="line">CMP AX,0</span><br><span class="line">JNF EXIT</span><br><span class="line">NEG AX</span><br><span class="line">MOV BUFFER,AX</span><br><span class="line">EXIT:...</span><br></pre></td></tr></table></figure>
<h3 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h3><p>加减运算是有符号还是无符号，由程序员来确定。例如，参与运算的是无符号的，则使用JB、JA指令；参与运算的是带符号的，则使用JL、JG指令。但是在乘除法中，有符号数和无符号数有各自的乘除法指令。<br>1、无符号乘法<br>MUL SRC<br>2、有符号数乘法<br>IMUL SRC<br>3、上述指令目的操作数为隐含寻址。隐含的操作数为被乘数，指令中给出的源操作数为乘数。SRC不能为立即数寻址。<br>4、乘法指令为字节型乘法还是字型的乘法，由源操作数来决定。<br>字节乘法：（DST）被乘数隐含在AL中，AX(AH:AL)&lt;-(AL)<em>SRC。八位乘八位，得到的结果为十六位。<br>字乘法：(DST)被乘数隐含在AX中，DX:AX&lt;-(AX)</em>SRC。十六位乘上十六位，结果表示为32位。<br>5、无符号乘法积的结果：不管是字乘还是字节乘，指令执行后只影响CF、OF两个标志。其余的状态标志没定义。<br>若OF = 0，CF = 0，说明高八位积无效。<br>若OF = 1，CF = 1，说明高八位有有效积。<br>6、有符号数乘法积的结果：<br>字节乘法：字节乘法：（DST）被乘数隐含在AL中，AX(AH:AL)&lt;-(AL)<em>SRC。指令执行后只影响CF、OF两个标志。<br>若OF = 0，CF = 0，说明AH中的积无效。AH中所存数据为AL中数据的符号的扩展。<br>字乘法：(DST)被乘数隐含在AX中，DX:AX&lt;-(AX)</em>SRC。<br>若OF = 0，CF = 0，说明DX中的积无效。AH中所存数据为AX中数据的符号的扩展。<br>若OF = 1，CF = 1，说明DX中有有效积。</p>
<h3 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h3><p>1、无符号数除法：DIV SRC<br>2、有符号数除法：IDIV SRC<br>3、SRC不能为立即数寻址。<br>4、乘法指令为字节型乘法还是字型的乘法，由源操作数来决定。<br>5、无符号字节型除法：(DST)被除数隐含在AX中，(AX)/(SRC)后，商放在AL，余数放在AH。<br>无符号字型除法：(DST)被除数隐含在DX:AX中，(DX:AX)/SRC,商放在了AX中，余数放在了DX中。<br>6、在有符号除法中，被除数为正，除数为正，则商为正，余数为正。若被除数为正，除数为负，则商为负，余数为正。若被除数为负，除数为正，则商为负，余数为负。若被除数为负，余数为负，则商为正，余数为负。<br>7、除法指令执行之后，对六个状态标志均无定义。</p>
<p>例：将存储器BUFFER1中的字节型无符号二进制数转换为十进制数。并将转换后的结果以分离BCD数形式存入BUFFER2以下单元。(个位数存在低地址单元)<br>思想：除十取余</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在DS段定义</span><br><span class="line">BUFFER1 DB ?</span><br><span class="line">BUFFER2 DB 3 dup(?)</span><br><span class="line"></span><br><span class="line">在CS段编程序</span><br><span class="line">MOV AL,BUFFER1</span><br><span class="line">MOV AH,0</span><br><span class="line">//当除数为八位时，被除数必须十六位，因此AX寄存器高位一定要清零。</span><br><span class="line">MOC CL,10</span><br><span class="line">//注意源操作数不能是立即数</span><br><span class="line">DIV CL</span><br><span class="line">//商在AL，余数在AH</span><br><span class="line">MOV BUFFER2,AH</span><br><span class="line">MOV AH,0</span><br><span class="line">//得到新的被除数</span><br><span class="line">DIV CL</span><br><span class="line">MOV BUFFER2+1,AH</span><br><span class="line">MOV BUFFER2+2,AL</span><br></pre></td></tr></table></figure>
<h3 id="符号扩展指令"><a href="#符号扩展指令" class="headerlink" title="符号扩展指令"></a>符号扩展指令</h3><p>1、CBW<br>无操作数，隐含地将AL中的八位二进制数扩展到AX中(十六位AH:AL)。AH中的内容是AL符号位的扩展。<br>2、CWD<br>无操作数，隐含地将AX中的十六位数扩展成32位，存储在DX:AX中。其中DX中的内容为AX中符号位的扩展。<br>3、这些指令的存在是为了在某些算术运算中类型要保持一致。<br>例：求Y = a<em>b+c-18。其中a、b、c三个变量都是字节型的。<br>1、注意y显然是十六位的，把a</em>b的结果存放在datay单元。<br>2、首先在ds段定义这些变量。然后在cs段编写程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//ds</span><br><span class="line">data DB ?</span><br><span class="line">datb DB ?</span><br><span class="line">datc DB ?</span><br><span class="line">daty DW ?</span><br><span class="line"></span><br><span class="line">//cs</span><br><span class="line">MOV AL,data</span><br><span class="line">IMUL datb</span><br><span class="line">//使用带符号数乘法，积在AX中，十六位，在下一步加c时，要对c进行符号位扩展</span><br><span class="line">MOV BX,AX</span><br><span class="line">MOV AL,datc</span><br><span class="line">CBW</span><br><span class="line">ADD AX,BX</span><br><span class="line">SUB AX,18</span><br><span class="line">MOV daty,AX</span><br></pre></td></tr></table></figure>
<p>注意，可以使用EQU语句定义符号常量，如上述程序中的18，可以定义为cc。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc EQU 18</span><br></pre></td></tr></table></figure>
<h3 id="BCD数调整指令"><a href="#BCD数调整指令" class="headerlink" title="BCD数调整指令"></a>BCD数调整指令</h3><p>+:分离BCD数、组合BCD数<br>-:分离BCD数、组合BCD数<br><em>:分离BCD数<br>/:分离BCD数，且是先调整后运算<br>+-</em>先运算再调整</p>
<p>1、加法BCD数调整指令<br>组合BCD：DAA<br>分离BCD：AAA<br>都隐含的是对AL中的内容的调整，执行结果会正常设置六个状态标志。<br>例子：组合BDC数运算56+73</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,56H</span><br><span class="line">ADD AL,73H</span><br><span class="line">DAA</span><br><span class="line">//高四位超过九需要修正，低四位没有超过九且没有向高位的进位所以不需要修正</span><br></pre></td></tr></table></figure>
<p>例子：分离BCD数运算4+8</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,04H</span><br><span class="line">ADD AL,08H</span><br><span class="line">AAA</span><br><span class="line">//低四位超过九需要加六修正，因为是分离BCD数，所以指令还会使高四位自动清零，并将AF标志传送给CF和AH，AH= 01H，最后的结果(AX) = 0102H。</span><br></pre></td></tr></table></figure>
<p>这是因为分离BCD数相加结果十位最大为1，所以可以直接根据AF标志位来确定AH的内容。<br>大部分场合使用的是组合BCD数的运算。<br>分离BDC数加法参与运算的不论是数字还是字符‘1’，运算得到的结果都相同。所以该指令又称为阿思科码加法调整指令。<br>2、减法BCD数调整指令<br>组合BCD数：DAS 减六修正原则,超过九则减六<br>分离BCD数：AAS<br>例：组合BCD数31-87</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,31H</span><br><span class="line">SUB AL,87H</span><br><span class="line">//有一位借位，存在CF中，最终输出结果要考虑CF寄存器内容</span><br><span class="line">DAS</span><br><span class="line">//AL = 44H,CF = 1，相当于借位了100，所以此时结果为44-100 = -56</span><br></pre></td></tr></table></figure>
<p>3、乘法BCD数调整指令<br>分离BCD数：AAM<br>例：分离BCD数7*8</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,07H</span><br><span class="line">MOV BL,08H</span><br><span class="line">MUL BL;</span><br><span class="line">//AX&lt;-(AL)*(BL) == 0038H</span><br><span class="line">AAM</span><br><span class="line">//对AX中得到的积做除十运算，商放在AH中，余数放在AL中</span><br><span class="line">最终(AX) = 0506H</span><br></pre></td></tr></table></figure>
<p>积的调整指令会调整SF、ZF标志。</p>
<p>4、除法BCD数的调整<br>AAD<br>1、只能是分离BCD数运算<br>2、先调整，再运算。<br>例：27/4BCD数除法运算</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,0207H</span><br><span class="line">MOV BL,04H</span><br><span class="line">AAD</span><br><span class="line">//隐含地对AX中的分离BCD数AX&lt;-(AH)*10+(AL)</span><br><span class="line">DIV BL</span><br></pre></td></tr></table></figure>
<p>AAD指令执行会影响PF，ZF，SF三个标志，剩余的三个标志没定义。</p>
<h2 id="逻辑运算类指令-五条"><a href="#逻辑运算类指令-五条" class="headerlink" title="逻辑运算类指令-五条"></a>逻辑运算类指令-五条</h2><p>1、段寄存器不能参加运算。</p>
<p>与：AND DST，SRC；(DST)按位与(SRC)，CF、OF标志自动清零。AF没定义。正常设置剩余的SF、ZF、PF标志。<br>或：OR DST，SRC；(DST)按位或(SRC),对标志位的设置与AND指令相同。<br>异或：XOR DST SRC;(DST)按位异或(SRC)。对标志位的设置与AND指令相同。<br>测试指令：TEST DST SRC；(DST)位对位与(SRC)，根据与的结果甚至标志，并不存放结果，对标志位的设置与AND指令相同。<br>非：NOT DST；(DST)&lt;-(DST)按位取反。对六个状态标志均无影响。<br>例：测BX中存储的十六位位数（从右向左编号）的位一和位二，当这两位同时为0时，AL内容置一。<br>与运算 0000 0000 0000 0110<br>若BX中的数据与该数与的结果为0，则ZF = 1。<br>同时应该注意到，题目要求在测试完BX中的数据后BX中的数据应该保持不变，应考虑使用<strong>TEST</strong>指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEST BX,0006H</span><br><span class="line">JZ L1</span><br><span class="line">MOV AL 0000H</span><br><span class="line">JMP L2</span><br><span class="line">L1:MOV AL 0FFFFH</span><br><span class="line">L2:...</span><br><span class="line">//字母开头的数值应该加一个0</span><br></pre></td></tr></table></figure>
<p>例：测BX中存储的十六位位数（从右向左编号）的位一和位二，当这两位只有一位为0时，AL内容置一。<br>与的结果有两种可能<br>1、0000 0000 0000 0100<br>2、0000 0000 0000 0010<br>测量结果的<a href="https://zhidao.baidu.com/question/543524852.html#:~:text=2%E3%80%81PF%EF%BC%88%E5%A5%87%E5%81%B6%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%89%20%E7%94%A8%E4%BA%8E%E5%8F%8D%E6%98%A0%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E4%B8%AD%E2%80%9C1%E2%80%9D%E7%9A%84%E4%B8%AA%E6%95%B0%E7%9A%84%E5%A5%87%E5%81%B6%E6%80%A7%EF%BC%8C%E5%A6%82%E6%9E%9C%E2%80%9C1%E2%80%9D%E7%9A%84%E4%B8%AA%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%EF%BC%8C%E5%88%99PF%3D1%EF%BC%8C%E5%90%A6%E5%88%99%EF%BC%8CPF%3D0%E3%80%82,3%E3%80%81AF%EF%BC%88%E8%BE%85%E5%8A%A9%E8%BF%9B%E4%BD%8D%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%89%20%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9C%8B%E6%9C%80%E5%90%8E%E5%9B%9B%E4%BD%8D%EF%BC%8C%E4%B8%8D%E8%AE%BA%E9%95%BF%E5%BA%A6%E4%B8%BA%E5%A4%9A%E5%B0%91%EF%BC%8C%E6%9C%80%E5%90%8E%E5%9B%9B%E4%BD%8D%E5%90%91%E5%89%8D%E6%9C%89%E8%BF%9B%E4%BD%8D%E6%88%96%E8%80%85%E5%80%9F%E4%BD%8D%EF%BC%8C%E5%88%99AF%3D1%EF%BC%8C%E5%90%A6%E5%88%99%EF%BC%8CAF%3D0%E3%80%82" target="_blank" rel="noopener">PF标志位</a>，PF = 1，1的个数为偶数,PF = 0,1的个数为奇数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEST BX,0006H</span><br><span class="line">JNP L1</span><br><span class="line">MOV AL 0000H</span><br><span class="line">JMP L2</span><br><span class="line">L1:MOV AL 0FFFFH</span><br><span class="line">L2:...</span><br><span class="line">//字母开头的数值应该加一个0</span><br></pre></td></tr></table></figure>
<p>例：将DX寄存器中的数据低七位取反，使用异或运算，低七位异或1，高九位异或0。</p>
<p>例：将CX寄存器中的数据高八位和低八位交换。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XCHG CH,CL</span><br></pre></td></tr></table></figure>
<h2 id="移位类指令（八条）"><a href="#移位类指令（八条）" class="headerlink" title="移位类指令（八条）"></a>移位类指令（八条）</h2><h3 id="移位指令（四条）"><a href="#移位指令（四条）" class="headerlink" title="移位指令（四条）"></a>移位指令（四条）</h3><p>把被移位的操作数看成无符号数，称为逻辑移位，把被移位的操作数看成有符号数，称为算数移位。</p>
<h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><p><strong>左移</strong>:SHL DST,CNT<br>DST为目的操作数，CNT为移位次数。<br>移位也是一种运算，段寄存器先然不能参加计算，作为目的操作数来使用。<br>当CNT = 1时，源操作数部分可以直接写出。当CNT大于1时，移位次数要用CL给出，事先要把移位次数MOV到CL中。这一规则适用于所有八条移位类指令。<br>移出的最高位到了CF中，最低位自动补零。<br>在执行完移位指令之后，CPU根据执行结果设置除了AF以外的状态标志。<br>移位次数超过一位之后，OF标志就没有意义了。<br><strong>右移</strong>:SHR DST,CNT<br>DST可以是字节型数据，也可以是字型数据。</p>
<h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><p><strong>左移</strong>：SAL DST,CNT<br>算数左移和逻辑左移是一回事。<br><strong>右移</strong>：SAR DST,CNT<br>带符号数最高位为符号位，右移过程中保持最高位不变。最低位移出去移到CF中。<br>例：5*12</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">MOV AL,5</span><br><span class="line">MOV BL 12</span><br><span class="line">MUL BL</span><br><span class="line">//但是时间花费比较大</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">5*12 = 5*(4+8) = 5*4+5*8</span><br><span class="line">MOV AL,5</span><br><span class="line">MOV CL 2</span><br><span class="line">SHL AL,CL</span><br><span class="line">//(AL) = 5*4</span><br><span class="line">MOV BL,AL</span><br><span class="line">SHL AL,1</span><br><span class="line">ADD AL,BL</span><br><span class="line">//(AL) = 5*12</span><br></pre></td></tr></table></figure>
<h3 id="循环移位（四条）"><a href="#循环移位（四条）" class="headerlink" title="循环移位（四条）"></a>循环移位（四条）</h3><p>操作数可以是字节型的，也可以是字型的，最高位移入CF中，同时最高位移入最低位中。也可以最高位移入CF中，CF中原来的内容移入最低位中。</p>
<h4 id="不带CF的循环移位"><a href="#不带CF的循环移位" class="headerlink" title="不带CF的循环移位"></a>不带CF的循环移位</h4><p><strong>左移</strong>:ROL DST,CNT<br><strong>右移</strong>:ROR DST,CNT</p>
<h4 id="带CF的循环移位"><a href="#带CF的循环移位" class="headerlink" title="带CF的循环移位"></a>带CF的循环移位</h4><p><strong>左移</strong>:RCL DST,CNT<br>指令中的C指的是带CF<br><strong>右移</strong>:RCR DST,CNT<br>CPU执行后，只影响CF和OF状态标志，对其余状态表示没定义。</p>
<p>例：若(BX) = 1011 0110B,CF = 1,(CL) = 3,则CPU执行RCR BX,CL指令后，(BX) = _H。<br>0000 0000 1011 0110<br>移位后为A016H。注意BX是十六位寄存器，虽然在本题中BX只给了8bit数据。</p>
<p>例：在DX:AX中存放了一个32bit数据m，求m*16<br>DX中有16bit数据，AX中有16bit数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV CL,4</span><br><span class="line">L1:SHL AX,1</span><br><span class="line">//将AX的最高位移入CF中，接下来通过循环移位指令将CF中的数据移入DX最低位中</span><br><span class="line">RCL DX,1</span><br><span class="line">LOOP L1</span><br></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1ZJ411b7Na?p=42" target="_blank" rel="noopener">目前更新进度42P</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" rel="tag"># 汇编语言</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/10/%E9%9A%8F%E6%84%9F/2021/" rel="prev" title="2021">
      <i class="fa fa-chevron-left"></i> 2021
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/28/%E7%BC%96%E7%A8%8B/leetcode/" rel="next" title="leetcode">
      leetcode <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#名词解释"><span class="nav-number">1.</span> <span class="nav-text">名词解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8086汇编语言程序中语句的种类"><span class="nav-number">2.</span> <span class="nav-text">8086汇编语言程序中语句的种类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#汇编语言中语句的组成"><span class="nav-number">3.</span> <span class="nav-text">汇编语言中语句的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#汇编语言程序设计中用到的常数及表达式"><span class="nav-number">4.</span> <span class="nav-text">汇编语言程序设计中用到的常数及表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标号、变量及伪指令"><span class="nav-number">5.</span> <span class="nav-text">标号、变量及伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标号"><span class="nav-number">5.1.</span> <span class="nav-text">标号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">5.2.</span> <span class="nav-text">变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令的分类"><span class="nav-number">6.</span> <span class="nav-text">指令的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据与转移地址的寻址方式"><span class="nav-number">7.</span> <span class="nav-text">数据与转移地址的寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#寻址方式"><span class="nav-number">7.1.</span> <span class="nav-text">寻址方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于寻找数据的寻址方式"><span class="nav-number">7.2.</span> <span class="nav-text">关于寻找数据的寻址方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接寻址"><span class="nav-number">7.3.</span> <span class="nav-text">直接寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器间接寻址"><span class="nav-number">7.4.</span> <span class="nav-text">寄存器间接寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器相对寻址"><span class="nav-number">7.5.</span> <span class="nav-text">寄存器相对寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基址变址寻址"><span class="nav-number">7.6.</span> <span class="nav-text">基址变址寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基址变址且相对寻址"><span class="nav-number">7.7.</span> <span class="nav-text">基址变址且相对寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐含寻址"><span class="nav-number">7.8.</span> <span class="nav-text">隐含寻址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于转移地址的寻址方式"><span class="nav-number">8.</span> <span class="nav-text">关于转移地址的寻址方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据传送指令"><span class="nav-number">9.</span> <span class="nav-text">数据传送指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通用数据数据传送指令"><span class="nav-number">9.1.</span> <span class="nav-text">通用数据数据传送指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取有效地址指令LEA"><span class="nav-number">9.2.</span> <span class="nav-text">取有效地址指令LEA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取地址指针指令LDS、LES"><span class="nav-number">9.3.</span> <span class="nav-text">取地址指针指令LDS、LES</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标志传送指令"><span class="nav-number">9.4.</span> <span class="nav-text">标志传送指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据交换指令XCHG"><span class="nav-number">9.5.</span> <span class="nav-text">数据交换指令XCHG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节转换指令XLAT"><span class="nav-number">9.6.</span> <span class="nav-text">字节转换指令XLAT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆栈操作指令"><span class="nav-number">9.7.</span> <span class="nav-text">堆栈操作指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算术运算类指令"><span class="nav-number">10.</span> <span class="nav-text">算术运算类指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加法指令"><span class="nav-number">10.1.</span> <span class="nav-text">加法指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#减法指令"><span class="nav-number">10.2.</span> <span class="nav-text">减法指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乘法指令"><span class="nav-number">10.3.</span> <span class="nav-text">乘法指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#除法指令"><span class="nav-number">10.4.</span> <span class="nav-text">除法指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号扩展指令"><span class="nav-number">10.5.</span> <span class="nav-text">符号扩展指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BCD数调整指令"><span class="nav-number">10.6.</span> <span class="nav-text">BCD数调整指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑运算类指令-五条"><span class="nav-number">11.</span> <span class="nav-text">逻辑运算类指令-五条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移位类指令（八条）"><span class="nav-number">12.</span> <span class="nav-text">移位类指令（八条）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#移位指令（四条）"><span class="nav-number">12.1.</span> <span class="nav-text">移位指令（四条）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑移位"><span class="nav-number">12.1.1.</span> <span class="nav-text">逻辑移位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算数移位"><span class="nav-number">12.1.2.</span> <span class="nav-text">算数移位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环移位（四条）"><span class="nav-number">12.2.</span> <span class="nav-text">循环移位（四条）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#不带CF的循环移位"><span class="nav-number">12.2.1.</span> <span class="nav-text">不带CF的循环移位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带CF的循环移位"><span class="nav-number">12.2.2.</span> <span class="nav-text">带CF的循环移位</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Monica</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Monica</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
