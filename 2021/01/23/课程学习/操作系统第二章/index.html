<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"monica-y.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第二章学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统第二章">
<meta property="og:url" content="https://monica-y.github.io/2021/01/23/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第二章学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.1.jpg">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FPCB2.1.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%902.1.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F2.1.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%812.1.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.1.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.2.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%812.2.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%812.2.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A22.2.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.2.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.3.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B62.3.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA2.3.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A22.3.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%922.3.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A22.3.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.3.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.4.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A82.4.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A12.4.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.4.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.5.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%98%E5%8C%962.5.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A72.5.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B2.5.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B2.5.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F2.5.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B2.5.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B2.5.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B2.5.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.5.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.6.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B2.6.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%E5%B1%82%E8%B0%83%E5%BA%A6%E7%9A%84%E8%81%94%E7%B3%BB%E5%AF%B9%E6%AF%942.6.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.6.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.7.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA2.7.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.7.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.8.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.8.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.9.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A12.9.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%882.9.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%882.9.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E4%BA%8C2.9.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%882.9.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.9.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.10.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.10.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.11.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.11.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.12.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.12.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.13.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.13.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.14.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.14.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.15.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.15.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B02.16.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B02.16.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.16.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%902.17.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%902.18.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B02.19.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.20.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.20.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.21.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%AD%BB%E9%94%81%E9%A5%A5%E9%A5%BF%E6%AD%BB%E5%BE%AA%E7%8E%AF2.21.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.21.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.22.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.22.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.23.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.24.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE2.24.png">
<meta property="og:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.24.png">
<meta property="article:published_time" content="2021-01-23T02:57:16.571Z">
<meta property="article:modified_time" content="2021-05-02T10:47:00.337Z">
<meta property="article:author" content="Monica">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://monica-y.github.io/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%882.1.jpg">

<link rel="canonical" href="https://monica-y.github.io/2021/01/23/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统第二章 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://monica-y.github.io/2021/01/23/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Monica">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统第二章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-23 10:57:16" itemprop="dateCreated datePublished" datetime="2021-01-23T10:57:16+08:00">2021-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 18:47:00" itemprop="dateModified" datetime="2021-05-02T18:47:00+08:00">2021-05-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <div class="post-description">第二章学习笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="进程的定义、组成、组织方式、特征"><a href="#进程的定义、组成、组织方式、特征" class="headerlink" title="进程的定义、组成、组织方式、特征"></a>进程的定义、组成、组织方式、特征</h2><p><img src="/images/操作系统知识总览2.1.jpg" alt="操作系统知识总览2.1"><br>这里要注意图片的格式是jpg还是png</p>
<p>一、进程的定义<br>1、程序：就是一个指令序列<br>2、早期的计算机（只支持单道程序）程序包含程序段和数据段，程序的代码放在程序段内，程序运行过程处理的数据放在数据段内（如变量）。<br>3、引入多道程序技术之后：内存中同时放入多道程序，各个程序的代码、运算数据存放的位置不同。操作系统要确定各个程序的存放位置。为了方便操作系统管理，完成各程序并发执行、引入了进程、进程实体的概念。<br>系统位每个运行的程序配置一个数据结构，称为进程控制块（PCB），用来描述进程的各种信息（如程序代码存放位置）<br>PCB、程序段、数据段三部分构成了进程实体（进程映像）<br>4、程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。<br>注意：PCB是进程存在的唯一标志。<br>5、进程是程序的一次执行过程。<br>6、进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>7、进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。<br>8、567从不同的角度定义了了进程，他们都强调“动态性”。<br>9、在引入进程实体的概念后，可把进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。<br>10、严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。不过，除非题目专门考察二者区别，否则可以认为进程实体就是进程。因此我们也可以说“进程有程序段、数据段、PCB三部分组成”。</p>
<p>二、进程的组成<br>1、进程（进程实体）由程序段、数据段、PCB三部分组成。<br>2、程序段存放的就是程序的代码本身。程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的变量就存放在数据段内。<br>3、操作系统通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息。<br><img src="/images/操作系统PCB2.1.png" alt="操作系统PCB2.1"><br>进程标识符PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程（类似于身份证号）<br>保存各种寄存器值的原因：当进程切换时需要把进程当前的运行状况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到哪一句。<br>4、另一种分类方式<br>进程标识符<br>处理机状态<br>进程调度信息<br>进程控制信息<br><img src="/images/操作系统进程的组成2.1.png" alt="操作系统进程的组成2.1"><br>注意：进程的管理者（操作系统）所需的数据都在PCB中。程序段和数据段存放的是程序本身运行所需的数据。</p>
<p>三、进程的组织<br>1、在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应当用适当的方式把这些PCB组织起来。<br>注：进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。<br><img src="/images/操作系统进程的组织方式2.1.png" alt="操作系统进程的组织方式2.1"><br>2、链接方式<br>执行指针：指向当前处于运行态（执行态）的进程。单CPU计算机中，同一时刻只会有一个进程处于运行态。<br>就绪队列指针：指向当前处于就绪态的进程<br>阻塞队列指针：指向当前处于阻塞态的进程，很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列。<br>3、索引方式<br>上述指针指向的是一个索引表而不是一个队列（链表）的队头。</p>
<p>四、进程的特征<br><img src="/images/操作系统进程的特征2.1.png" alt="操作系统进程的特征2.1"><br>1、动态性是进程最基本的特征。<br>2、进程是资源分配、接受调度的基本单位。<br>3、异步性会导致并发程序执行结果的不确定性。具体会在“进程同步”相关小节进行学习。</p>
<p><img src="/images/操作系统知识回顾2.1.png" alt="操作系统知识回顾2.1"><br>1、PCB是进程存在的唯一标志。<br>2、进程管理者（操作系统）所需的数据都在PCB中<br>3、程序本身的运行所需的数据在程序段、数据段中</p>
<h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><p><img src="/images/操作系统知识总览2.2.png" alt="操作系统知识总览2.2"></p>
<p>一、进程的状态—三种基本状态<br>1、进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。<br><img src="/images/操作系统进程的三种基本状态2.2.png" alt="操作系统进程的三种基本状态2.2"><br>2、运行态注意：单核处理机环境下，每一时刻最多只有一个进程处于运行态。（双核环境下可以同时有两个进程处于运行态）<br>3、就绪态注意：进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即：万事俱备，只欠CPU<br>4、阻塞态注意：等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。</p>
<p>二、进程的状态—另外两种状态<br>1、操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB（如：为进程分配PID）<br>2、进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误），需要撤销进程。<br>操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收、撤销进程PCB等工作。<br><img src="/images/操作系统进程的另外两种状态2.2.png" alt="操作系统进程的另外两种状态2.2"></p>
<p>三、进程状态的转换<br><img src="/images/操作系统进程状态的转换2.2.png" alt="操作系统进程状态的转换2.2"><br>1、运行态-&gt;阻塞态是一种进程自身做出的主动行为。<br>2、阻塞态-&gt;就绪态不是进程自身能控制得，是一种被动行为。<br>3、注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态（因为进入阻塞态是进程主动请求得，必然需要进程在运行时才能发出这种请求）</p>
<p><img src="/images/操作系统知识回顾2.2.png" alt="操作系统知识回顾2.2"></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p><img src="/images/操作系统知识总览2.3.png" alt="操作系统知识总览2.3"></p>
<p>一、进程控制<br>1、进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。<br>简化理解：进程控制就是要实现进程状态转换<br><img src="/images/操作系统实现进程控制2.3.png" alt="操作系统实现进程控制2.3"><br>2、用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即原子操作。<br>3、原语采用“关中断指令”和“开中断指令”实现<br>4、显然，关/开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令。</p>
<p>二、进程控制相关的原语<br>1、学习技巧：进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情。更新PCB中的信息、将PCB插入合适的队列、分配/回收资源。<br>2、更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）<br>a、所有的进程控制原语一定都会修改进程状态标志<br>b、剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>c、某进程开始运行前必然要恢复其运行环境<br><img src="/images/操作系统进程的创建2.3.png" alt="操作系统进程的创建2.3"><br>3、创建原语：无-&gt;创建态-&gt;就绪态<br><img src="/images/操作系统进程的终止2.3.png" alt="操作系统进程的终止2.3"><br>4、撤消原语：就绪态/阻塞态/运行态-&gt;终止态-&gt;无。<br><img src="/images/操作系统进程的阻塞和唤醒2.3.png" alt="操作系统进程的阻塞和唤醒2.3"><br>5、阻塞原语：运行态-&gt;阻塞态<br>6、唤醒原语：阻塞态-&gt;就绪态<br>7、因何事阻塞，就应由何事唤醒<br>8、阻塞原语唤醒原语必须成对使用<br><img src="/images/操作系统进程的切换2.3.png" alt="操作系统进程的切换2.3"><br>9、切换原语：运行态-&gt;阻塞态/就绪态；就绪态-&gt;运行态<br><img src="/images/操作系统知识回顾2.3.png" alt="操作系统知识回顾2.3"></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p><img src="/images/操作系统知识总览2.4.png" alt="操作系统知识总览2.4"></p>
<p>一、什么是进程通信<br>1、顾名思义，进程通信就是指进程之间的信息交换。<br>2、进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。<br>3、为了保证安全，一个进程不能直接访问另一个进程的地址空间。<br>4、但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。<br>5、进程通信的方法：共享存储、消息传递、管道通信。</p>
<p>二、共享存储<br>操作系统进程通信共享存储2.4<br><img src="/images/操作系统进程通信共享存储2.4.png" alt="操作系统进程通信共享存储2.4"><br>1、两个进程对共享空间的访问必须是互斥的（互斥访问同故宫操作系统提供的工具实现）。<br>2、操作系统只负责提供共享空间和同步互斥工具（如P，V操作）<br>3、共享存储：基于数据结构的共享、基于存储区的共享<br>4、基于数据结构的共享：比如共享空里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。<br>5、基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</p>
<p>三、管道通信<br><img src="/images/操作系统进程通信管道通信2.4.png" alt="操作系统进程通信管道通信2.4"><br>1、“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。<br>2、管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。<br>3、各进程要互斥地访问管道。<br>4、数据以字符流的形式写入管道，当管道写满时，写进程的write（）系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read（）系统调用将被阻塞。<br>5、如果没写满，就不允许读。如果没读空，就不允许写。<br>6、数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</p>
<p>四、消息传递<br>1、进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。<br>2、消息包括消息头和消息体两部分。消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）<br>３、消息传递的两种方式<br>直接通信方式:消息直接挂到接收进程的消息缓冲队列上<br>间接通信方式:消息要先发送到中间实体(信箱)中,因此也称”信箱通信方式”.Eg:计网中的电子邮件系统<br><img src="/images/操作系统知识回顾2.4.png" alt="操作系统知识回顾2.4"></p>
<h2 id="线程概念多线程模型"><a href="#线程概念多线程模型" class="headerlink" title="线程概念多线程模型"></a>线程概念多线程模型</h2><p><img src="/images/操作系统知识总览2.5.png" alt="操作系统知识总览2.5"><br>一、线程<br>1、有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。<br>2、传统的进程是程序执行流的最小单位。<br>3、引入线程后，线程成为了程序执行流的最小单位。<br>4、可以把线程理解为“轻量级进程”。<br>5、线程是一个基本的CPU执行单元，也是进程执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务。<br>6、引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。<br><img src="/images/操作系统引入线程的变化2.5.png" alt="操作系统引入线程的变化2.5"><br><img src="/images/操作系统线程的属性2.5.png" alt="操作系统线程的属性2.5"></p>
<p>二、线程的实现方式<br>1、用户级线程（User-Level Thread,ULT）<br><img src="/images/操作系统用户级线程2.5.png" alt="操作系统用户级线程2.5"><br>2、内核级线程<br><img src="/images/操作系统内核级线程2.5.png" alt="操作系统内核级线程2.5"><br>3、在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n各用户级线程映射到m各内核级线程上（n&gt;=m）<br><img src="/images/操作系统线程的实现方式2.5.png" alt="操作系统线程的实现方式2.5"></p>
<p>三、多线程模型<br>1、在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。<br><img src="/images/操作系统多对一模型2.5.png" alt="操作系统多对一模型2.5"><br><img src="/images/操作系统一对一模型2.5.png" alt="操作系统一对一模型2.5"><br><img src="/images/操作系统多对多模型2.5.png" alt="操作系统多对多模型2.5"><br><img src="/images/操作系统知识回顾2.5.png" alt="操作系统知识回顾2.5"></p>
<h2 id="处理机调度概念、层次"><a href="#处理机调度概念、层次" class="headerlink" title="处理机调度概念、层次"></a>处理机调度概念、层次</h2><p><img src="/images/操作系统知识总览2.6.png" alt="操作系统知识总览2.6"><br>一、调度的基本概念<br>1、当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。<br>2、在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。<br>3、处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。<br>二、调度的三个层次—高级调度<br>1、由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。<br>2、高级调度（作业调度）：按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（PCB），以使它（们）获得竞争处理机的权利。<br>3、高级调度使辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。<br>三、调度的三个层次—中级调度<br>1、引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<br>2、这么做的目的是为了提高内存利用率和系统吞吐量。<br>3、暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到挂起队列中。<br>4、中级调度（内存调度）：就是要决定将哪个处于挂起状态的进程重新调入内存。<br>5、一个进程可能会被多次调出、调入内存，因此中级调度发生的频率比高级调度更高。<br>四、进程挂起态与七状态模型<br>1、暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）。<br>2、挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。<br>3、五状态-&gt;七状态<br><img src="/images/操作系统七状态模型2.6.png" alt="操作系统七状态模型2.6"><br>4、有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。<br>五、调度的三个层次—低级调度<br>1、低级调度（进程调度）其主要任务时按照某种方法和策略从就绪对列中选取一个进程，将处理机分配给它。（调度算法要研究的问题）<br>2、进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。<br>3、进程调度的频率很高，一般几十毫秒一次。<br><img src="/images/操作系统三层调度的联系对比2.6.png" alt="操作系统三层调度的联系对比2.6"><br><img src="/images/操作系统知识回顾2.6.png" alt="操作系统知识回顾2.6"></p>
<h2 id="进程调度的时机、切换与过程、调度方式"><a href="#进程调度的时机、切换与过程、调度方式" class="headerlink" title="进程调度的时机、切换与过程、调度方式"></a>进程调度的时机、切换与过程、调度方式</h2><p><img src="/images/操作系统知识总览2.7.png" alt="操作系统知识总览2.7"><br>一、进程调度的时机<br>1、进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。<br><img src="/images/操作系统进程调度的时机2.7.png" alt="操作系统进程调度的时机2.7"><br>2、进程在操作系统内核程序临界区中不能进行调度与切换。<br>错误表述：进程处于临界区时不能进行处理机调度。（区分普通临界区和内核临界区）<br>3、临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。<br>4、临界区：访问临界资源的那段代码。<br>5、内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）<br>6、如果进程还没退出临界区（还没解锁）就进行进程调度，此时进程调度相关的程序也需要访问就绪队列，但此时就绪对列被锁住了，因此又无法顺利进行进程调度。<br>因此内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。要让进程尽快的完成对临界资源的访问从而尽快解锁。<br>7、在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。<br>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。<br>8、虽然需要进行进程调度与切换的情况有两种（主动放弃和被动放弃），但是在有的操作系统中，只允许进程主动放弃处理机。有的操作系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）。<br>9、进程在操作系统内核程序临界区中不能进行进程的调度与切换，但是进程在普通临界区中时可以进行调度、切换的。<br>二、进程调度的方式<br>1、非剥夺调度方式，又称非抢占式。即，只允许进程主动放弃处理机。在运行过程中即便又更紧迫的任务到达，当前进程依然会继续使用处理机，知道该进程终止或主动要求进入阻塞态。<br>特点：实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。<br>2、剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<br>特点：可以优先处理更紧急的进程，也可实现让各个进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。<br>三、进程的切换与过程<br>1、“狭义的进程调度”与“进程切换”的区别：<br>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）<br>2、进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。<br>3、广义的进程调度包含了选择一个进程和进程切换两个步骤。<br>4、进程切换的过程主要完成了：<br>（1）对原来运行进程各种数据的保存。<br>（2）对新的进程各种数据的恢复。（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）<br>5、进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。<br><img src="/images/操作系统知识回顾2.7.png" alt="操作系统知识回顾2.7"></p>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><p><img src="/images/操作系统知识总览2.8.png" alt="操作系统知识总览2.8"><br>一、CPU利用率<br>1、由于早期的CPU造价极其昂贵，因此人们会希望让CPU尽可能多地工作。<br>2、CPU利用率：指CPU“忙碌”的时间占总时间的比例。</p>
<script type="math/tex; mode=display">利用率 = \frac{忙碌的时间}{总时间}</script><p>3、有的题目还会要求计算某种设备的利用率。通常会考察多道程序并发执行的情况，可以用“甘特图”来辅助计算。<br>二、系统吞吐量<br>1、对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。</p>
<script type="math/tex; mode=display">系统吞吐量 = \frac{总共完成了多少道作业}{总共花了多少时间}</script><p>三、周转时间<br>1、对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。<br>2、周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。<br>3、它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个过程中，可能发生多次。<br>(作业)周转时间 = 作业完成时间 - 作业提交时间</p>
<script type="math/tex; mode=display">平均周转时间 = \frac{各作业周转时间之和}{作业数}</script><p>对于用户来说，更关心自己的单个作业的周转时间。<br>对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值。<br>4、<script type="math/tex">带权周转时间 = \frac{作业周转时间}{作业实际运行的时间} = \frac{作业完成时间 - 作业提交时间}{作业实际运行的时间}</script><br>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。<br>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。<br>5、带权周转时间必然$\geqslant 1$.因为周转时间包含了作业实际运行的时间。<br>6、带权周转时间与周转时间都是越小越好。<br>7、<script type="math/tex">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</script><br>四、等待时间<br>1、计算机的用户希望自己的作业尽可能少的等待处理机。<br>2、等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。<br>1）作业在后备队列等待被服务（调度）<br>2）作业调入内存后，建立相应的进程。这个进程会被CPU服务、会被I/O设备服务，当然也会有等待被服务的时候。<br>3、对于$进程$来说，等待时间就是指$进程建立后$等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。（此时I/O设备正在服务进程）<br>4、对于$作业$来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。<br>注意区分进程和作业等待时间定义的不同<br>5、一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。<br>五、响应时间<br>1、对于计算机用户来说，会希望自己提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。<br>2、响应时间，指从用户提交请求到首次产生响应所用的时间。<br><img src="/images/操作系统知识回顾2.8.png" alt="操作系统知识回顾2.8"></p>
<h2 id="调度算法-先来先服务、最短作业优先、最高响应比优先"><a href="#调度算法-先来先服务、最短作业优先、最高响应比优先" class="headerlink" title="调度算法 先来先服务、最短作业优先、最高响应比优先"></a>调度算法 先来先服务、最短作业优先、最高响应比优先</h2><p><img src="/images/操作系统知识总览2.9.png" alt="操作系统知识总览2.9"><br>Tips:各种调度算法的学习思路<br>1、算法思想<br>2、算法规则<br>3、这种调度算法是用于作业调度还是进程调度<br>4、抢占式？非抢占式？<br>5、优点和缺点<br>6、是否会导致饥饿（某进程/作业长期得不到服务）<br>一、先来先服务（FCFS，First Come First Serve）<br>1、算法思想：主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）<br>2、算法规则：按照作业/进程到达的先后顺序进行服务<br>3、用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。<br>4、非抢占式算法。<br>5、先来先服务调度算法：按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务。<br><img src="/images/操作系统先来先服务2.9.png" alt="操作系统先来先服务2.9"><br>6、优缺点<br>优点：公平，算法实现简单<br>缺点：排在长作业（进程）后面的短作业需要等待很长时间。带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利。（Eg：排队买奶茶…）<br>7、不会导致饥饿。<br>二、短作业优先（SJF，Shortest Job First）<br>1、算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间。<br>2、算法规则：最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）。<br>3、用于作业/进程调度：既可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF，Shortest Process First）算法”。<br>4、SJF和SPF是非抢占式的算法。但是也有抢占式的版本—最短剩余时间优先算法（SRTN，Shortest Remaining Time Next）<br>5、短作业/进程优先调度算法：每次调度时选择当前已到达且运行时间最短的作业/进程。<br><img src="/images/操作系统短作业优先2.9.png" alt="操作系统短作业优先2.9"><br>6、抢占式的短作业优先算法又称最短剩余时间优先算法（SRTN）：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。<br><img src="/images/操作系统最短剩余时间优先2.9.png" alt="操作系统最短剩余时间优先2.9"><br><img src="/images/操作系统短作业优先二2.9.png" alt="操作系统短作业优先二2.9"><br>7、如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的。<br>8、很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”<br>严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少。<br>应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”<br>或者说“在所有进程几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少”；<br>如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先，SRTN算法）的平均等待时间、平均周转时间最少”。<br>9、虽然严格来说，SJF的平均等待时间、平均周转时间不一定最少，但相比于其他算法（如FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间。<br>10、如果选择题中遇到“SJF算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是又很明显的错误，如果没有更合适的选项，那也应该选择该选项。<br>11、优缺点<br>优点：“最短的”平均等待时间、平均周转时间<br>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。<br>12、会导致饥饿。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”。<br>13、对FCFS和SJF两种算法地思考…<br>FCFS算法是在每次服务地时候选择一个等待时间最长地作业（进程）为其服务。但是没有考虑到作业地运行时间，因此导致了对短作业不友好地问题。<br>SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题。<br>设计一个算法，既考虑到各个作业的等待时间，也能兼顾运行时间。<br>三、高响应比优先算法（HRRN，Highest Response Ratio Next）<br>1、算法思想：要综合考虑作业/进程的等待时间和要求服务的时间<br>2、算法规则：在每次调度时先计算各个作业/进程的响应比，选择相应比最高的作业/进程为其服务</p>
<script type="math/tex; mode=display">响应比 = \frac{等待时间+要求服务时间}{要求服务时间}</script><p>响应比$\geqslant 1$<br>3、用于作业/进程调度:既可用于作业调度，也可用于进程调度<br>4、非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。<br>5、高响应比优先算法：非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。<br><img src="/images/操作系统高响应比优先2.9.png" alt="操作系统高响应比优先2.9"><br>6、优缺点<br>1）综合考虑了等待时间和运行时间（要求服务时间）<br>2）等待时间相同时，要求服务时间短的优先（SJF的优点）<br>3）要求服务时间相同时，等待时间长的优先（FCFS的优点）<br>4）对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿问题。<br>7、不会导致饥饿。<br><img src="/images/操作系统知识回顾2.9.png" alt="操作系统知识回顾2.9"></p>
<h2 id="调度算法-时间片轮转-优先级调度-多级反馈队列"><a href="#调度算法-时间片轮转-优先级调度-多级反馈队列" class="headerlink" title="调度算法 时间片轮转 优先级调度 多级反馈队列"></a>调度算法 时间片轮转 优先级调度 多级反馈队列</h2><p><img src="/images/操作系统知识总览2.10.png" alt="操作系统知识总览2.10"><br>Tips:各种调度算法的学习思路<br>1、算法思想<br>2、算法规则<br>3、这种调度算法是用于作业调度还是进程调度<br>4、抢占式？非抢占式？<br>5、优点和缺点<br>6、是否会导致饥饿（某进程/作业长期得不到服务）<br>一、时间片轮转（RR，Round-Robin）<br>1、算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。<br>2、算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。<br>3、用于进程/作业调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）。<br>4、抢占式算法。若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到。<br>5、时间片轮转调度算法常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间。<br>6、时间片轮转调度算法：轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列对头的进程）<br>7、注意，2时刻，P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况，默认新到达的进程先进入就绪队列。<br>8、若P1进程已经处理完成但时间片还没用完，P1会主动放弃处理机。<br>9、如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。<br>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。<br>一般来说，设计时间片要让切换进程的开销占比不超过1%。<br>10、优缺点<br>优点：公平、响应快，适用于分时操作系统。<br>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。<br>11、不会导致饥饿。<br>二、优先级调度算法<br>1、算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。<br>2、算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。<br>3、既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中。<br>4、抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。<br>5、就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。<br>6、根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。<br>静态优先级：创建进程时确定，之后一直不变。<br>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。<br>7、通常：系统进程优先级高于用户进程。<br>前台进程优先级高于后台进程。<br>操作系统更偏好I/O型进程。（或称I/O繁忙型进程）I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。<br>注：与I/O型进程相对的是计算型进程（或称CPU繁忙型进程）<br>8、动态优先级的调整策略：<br>可以从追求公平、提升资源利用率等角度考虑。<br>如果某进程在就绪队列中等待了很长时间，则可以适当提高其优先级。<br>如果某进程占用处理机运行了很长时间，则可适当降低其优先级。<br>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级。<br>9、优缺点：<br>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程地偏好程度。<br>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿。<br>10、会导致饥饿。<br>三、多级反馈队列调度算法<br>1、算法思量：对其他调度算法地折中权衡。<br>2、算法规则：<br>1）设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。<br>2）新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级地队列，则重新放回该队列队尾。<br>3）只有第k级队列为空时，才会为k+1级队头地进程分配时间片。<br>3、用于进程调度。<br>4、抢占式的算法。在k级队列的进程运行过程中，若更上级的队列（1到k-<br>1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列（本级队列）队尾。<br>5、优缺点：<br>优点：对各种类型进程相对公平（FCFS的优先）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O进程就可以保持较高优先级）<br>6、会导致饥饿。<br><img src="/images/操作系统知识回顾2.10.png" alt="操作系统知识回顾2.10"><br>注：比起早期的批处理操作系统来说，由于计算机造假大幅度降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法）</p>
<h2 id="进程同步-进程互斥"><a href="#进程同步-进程互斥" class="headerlink" title="进程同步 进程互斥"></a>进程同步 进程互斥</h2><p><img src="/images/操作系统知识总览2.11.png" alt="操作系统知识总览2.11"><br>一、进程同步<br>1、知识点回顾：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。<br>2、在管道通信中，读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行地先后顺序是不确定地。而实际应用中，又必须按照“写数据-&gt;读数据”的顺序来执行。如何解决这种异步问题，就是“进程同步”所讨论的内容。<br>3、同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。<br>二、进程互斥<br>1、进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免地需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I/O设备）<br>2、我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。<br>3、对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。互斥进程指当一个进程访问临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。<br>4、对于临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    entry section;//进入区</span><br><span class="line">    critical section;//临界区</span><br><span class="line">    <span class="built_in">exit</span> section;//退出区</span><br><span class="line">    remainder section;//剩余区</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>1)进入区：负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区。<br>2）临界区：访问临界资源的那段代码。<br>3）退出区：负责解除正在访问临界资源的标志（可理解为“解锁”）。<br>4）剩余区：做其他处理。<br>5、临界区是进程中访问临界资源的代码段。<br>6、进入区和退出区是负责实现互斥的代码段。<br>7、临界区也可称为“临界段”。<br>8、为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：<br>1）空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；<br>2）忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。<br>3）有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）。<br>4）让权等待。当进程不能进入临界区，应立即释放处理机，防止进程忙等待。<br><img src="/images/操作系统知识回顾2.11.png" alt="操作系统知识回顾2.11"></p>
<h2 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h2><p><img src="/images/操作系统知识总览2.12.png" alt="操作系统知识总览2.12"><br>学习提示：<br>1、理解各个算法的思想、原理。<br>2、结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么。<br>3、分析各算法存在的缺陷（结合“实现互斥要遵循的四个原则”进行分析）<br>二、单标志法<br>1、算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int turn = 0;//turn 表示当前允许进入临界区的进程号</span><br><span class="line"></span><br><span class="line">P0进程：</span><br><span class="line"><span class="keyword">while</span>(turn !=0);(1)</span><br><span class="line">critical section;(2)</span><br><span class="line">turn = 1;(3)</span><br><span class="line">remainder section;(4)</span><br><span class="line"></span><br><span class="line">P1进程：</span><br><span class="line"><span class="keyword">while</span>(turn !=1);(5)//进入区</span><br><span class="line">critical section;(6)//临界区</span><br><span class="line">turn = 0;(7)//退出区</span><br><span class="line">remainder section;(8)//剩余区</span><br></pre></td></tr></table></figure>
<p>2、turn 的初值为0，即刚开始只允许0号进程进入临界区。<br>3、若P1先上处理机运行，则会一直卡在(5)。直到P1的时间片用完，发生调度，切换P0上处理机运行。代码(1)不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间即使切换回P1，P1依然会卡在(5)。<br>4、只有P0在退出区将turn改为1后，P1才能进入临界区。<br>5、因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”。<br>6、turn 表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按P0-&gt;P1-&gt;P0-&gt;P1-&gt;……这样轮流访问。<br>7、这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但并不允许P1访问。<br>8、因此，单标志法存在的主要问题是：违背“空闲让进”原则。<br>二、双标志先检查法<br>1、算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] = true”意味着0号进程P0现在想要进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool flag[2];//表示进入临界区意愿的数组</span><br><span class="line">flag[0] = <span class="literal">false</span>;</span><br><span class="line">flag[1] = <span class="literal">false</span>;//刚开始设置为两个进程都不想进入临界区</span><br><span class="line"></span><br><span class="line">P0进程：</span><br><span class="line"><span class="keyword">while</span>(flag[1]);(1)</span><br><span class="line">flag[0] = <span class="literal">true</span>;(2)</span><br><span class="line">critical section;(3)</span><br><span class="line">flag[0] = <span class="literal">false</span>;(4)</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line">P1进程：</span><br><span class="line"><span class="keyword">while</span>(flag[0]);(5)//如果此时P0想进入临界区，P1就一直循环等待</span><br><span class="line">flag[1] = <span class="literal">true</span>;(6)//标记为P1进程想要进入临界区</span><br><span class="line">critical section;(7)//访问临界区</span><br><span class="line">flag[1] = <span class="literal">false</span>;(8)//访问完临界区，修改标记为P1不想使用临界区</span><br><span class="line">critical section;</span><br></pre></td></tr></table></figure>
<p>2、若按照(1)(5)(2)(6)(3)(7)….的顺序执行，P0和P1将会同时访问临界区。<br>3、因此，双标志先检查法的主要问题是：违反“忙则等待”原则。<br>4、原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。<br>三、双标志后检查法<br>1、算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool flag[2];//表示进入临界区意愿的数组</span><br><span class="line">flag[0] = <span class="literal">false</span>;</span><br><span class="line">flag[1] = <span class="literal">false</span>;//刚开始设置为两个进程都不想进入临界区</span><br><span class="line"></span><br><span class="line">P0进程：</span><br><span class="line">flag[0] = <span class="literal">true</span>;(1)</span><br><span class="line"><span class="keyword">while</span>(flag[1]);(2)</span><br><span class="line">critical section;(3)</span><br><span class="line">flag[0] = <span class="literal">false</span>;(4)</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line">P1进程：</span><br><span class="line">flag[1] = <span class="literal">true</span>;(5)//标记为P1进程想要进入临界区</span><br><span class="line"><span class="keyword">while</span>(flag[0]);(6)//如果此时P0想进入临界区，P1就一直循环等待</span><br><span class="line">critical section;(7)//访问临界区</span><br><span class="line">flag[1] = <span class="literal">false</span>;(8)//访问完临界区，修改标记为P1不想使用临界区</span><br><span class="line">critical section;</span><br></pre></td></tr></table></figure>
<p>2、若按照(1)(5)(2)(6)….的顺序执行，P0和P1将都无法进入临界区。<br>3、因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。<br>4、两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。<br>四、Peterson算法<br>1、算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool flag[2];//表示进入临界区意愿的数组，初始值都是<span class="literal">false</span></span><br><span class="line">int turn = 0;//turn 表示优先让哪个进程进入临界区</span><br><span class="line"></span><br><span class="line">P0进程：</span><br><span class="line">flag[0] = <span class="literal">true</span>;(1)</span><br><span class="line">turn = 1;(2)</span><br><span class="line"><span class="keyword">while</span>(flag[1] &amp;&amp; turn == 1);(3)</span><br><span class="line">critical section;(4)</span><br><span class="line">flag[0] = <span class="literal">false</span>;(5)</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line">P1进程：</span><br><span class="line">flag[1] = <span class="literal">true</span>;(6)//表示自己想进入临界区</span><br><span class="line">turn = 0;(7)//可以优先让对方进入临界区</span><br><span class="line"><span class="keyword">while</span>(flag[0] &amp;&amp; turn == 0);(8)//对方想进，且最后一次是自己“让梨”(turn == 0)，那自己就循环等待</span><br><span class="line">critical section;(9)</span><br><span class="line">flag[1] = <span class="literal">false</span>;(10)//访问完临界区，表示自己已经不想访问临界区了</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>2、进入区：<br>1）主动争取；<br>2）主动谦让；<br>3）检查对方是否也想使用，且最后一次是不是自己说了“客气话”<br>3、Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是仍然未遵循让权等待的原则。<br><img src="/images/操作系统知识回顾2.12.png" alt="操作系统知识回顾2.12"></p>
<h2 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h2><p><img src="/images/操作系统知识总览2.13.png" alt="操作系统知识总览2.13"><br>学习提示：<br>1、了解各方法的原理。<br>2、了解各方法的优缺点。<br>一、中断屏蔽方法<br>1、利用“开/关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关中断;//关中断后即不允许当前进程被中断，也必然不会发生进程切换</span><br><span class="line">临界区;</span><br><span class="line">开中断;//直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span><br></pre></td></tr></table></figure>
<p>2、优点：简单<br>缺点：不适用于多处理机（只能限制当前处理机进程的切换）；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）<br>二、TestAndSet指令<br>1、简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令。<br>2、TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//布尔型共享变量lock表示当前临界区是否被加锁</span><br><span class="line">//<span class="literal">true</span> 表示已加锁，<span class="literal">false</span>表示未加锁</span><br><span class="line">bool TestAndSet(bool *lock)&#123;</span><br><span class="line">    bool old;</span><br><span class="line">    old = *lock;//old用来存放lock原来的值</span><br><span class="line">    *lock = <span class="literal">true</span>;//无论之前是否已加锁，都将lock设为<span class="literal">true</span></span><br><span class="line">    <span class="built_in">return</span> old;//返回lock原来的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//以下是使用TSL指令实现互斥的算法逻辑</span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock));//“上锁”并“检查”</span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;//“解锁”</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>
<p>3、若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是true，则执行TSL后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。<br>4、相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。<br>5、优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。<br>6、缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。<br>三、Swap指令<br>1、有的地方也叫Exchange指令，或简称XCHG指令。<br>2、Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Swap指令的作用是交换两个变量的值</span><br><span class="line">Swap(bool *a,bool *b)&#123;</span><br><span class="line">    bool temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//以下是用Swap指令实现互斥的算法逻辑</span><br><span class="line">//lock表示当前临界区是否被加锁</span><br><span class="line">bool old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old == <span class="literal">true</span>)&#123;</span><br><span class="line">    Swap(&amp;lock,&amp;old);</span><br><span class="line">&#125;</span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>
<p>3、逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在old变量上），再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。<br>4、优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。<br>5、缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。<br><img src="/images/操作系统知识回顾2.13.png" alt="操作系统知识回顾2.13"></p>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p><img src="/images/操作系统知识总览2.14.png" alt="操作系统知识总览2.14"><br>一、信号量机制<br>1、用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。<br>2、信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。<br>3、原语是一种特殊的程序段，其执行只能一气呵成，不可能被中断。原语是由于关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。<br>4、一对原语：wait（S）原语和signal（S）原语，可以把原语理解成为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。<br>5、wait、signal原语常简称为P、V操作（来自荷兰语proberen:尝试和verhogen:增加）。因此，做题的时候常把wait（S）、signal（S）两个操作分别写为P（S）、V（S）。<br>二、信号量机制—整型信号量<br>1、用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。<br>2、Eg：某计算机系统中有一个打印机…</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int S = 1;//初始化整型信号量S，表示当前系统中可用的打印机资源数</span><br><span class="line"></span><br><span class="line">void <span class="built_in">wait</span>(int S)&#123;//<span class="built_in">wait</span>原语，相当于“进入区”</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= 0);//如果资源数不够，就一直循环等待</span><br><span class="line">    S = S - 1;//如果资源数够，则占用一个资源</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void signal(int S)&#123;//signal原语，相当于“退出区”</span><br><span class="line">    S = S + 1;//使用完资源后，在退出区释放资源</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进程P0：</span><br><span class="line"><span class="built_in">wait</span>(&amp;S);//进入区，申请资源</span><br><span class="line">使用打印机资源...//临界区，访问资源</span><br><span class="line">signal(&amp;S);//退出区，释放资源</span><br></pre></td></tr></table></figure>
<p>3、“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。<br>4、存在的问题：不满足“让权等待”原则，会发生“忙等”。<br>三、信号量机制—记录型信号量<br>1、整型信号量的缺陷时存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//记录型信号量的定义</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int value;//剩余资源数</span><br><span class="line">    struct process *L;//等待队列</span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line">//某进程需要使用资源时，通过<span class="built_in">wait</span>原语申请</span><br><span class="line">void <span class="built_in">wait</span>(semaphore S)&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; 0)&#123;</span><br><span class="line">        block(S.L);</span><br><span class="line">        //如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把它挂到信号量S的等待队列（即阻塞队列）中。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//进程使用完资源后，通过signal原语释放</span><br><span class="line">void signal(semaphore S)&#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= 0)&#123;</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">        //释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在考研题目中wait（S）、signal（S）也可以记为P（S）、V（S），这对原语可用于实现系统资源的“申请”和“释放”。<br>3、S.value的初值表示系统中某种资源的数目。<br>3、对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行S.value—,表示资源数减1，当S.value<0时表示该类资源已分配完毕，因此进程应调用block原语进行自我阻塞（当前运行的进程从运行态->阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。<br>4、对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行S.value++,表示资源数加1，若加1后仍是S.value&lt;=0,表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态-&gt;就绪态）。<br><img src="/images/操作系统知识回顾2.14.png" alt="操作系统知识回顾2.14"><br>5、若考试中出现P（S）、V（S）的操作，除非特别说明，否则默认S为记录型信号量。</p>
<h2 id="用信号量机制实现进程互斥、同步、前驱关系"><a href="#用信号量机制实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量机制实现进程互斥、同步、前驱关系"></a>用信号量机制实现进程互斥、同步、前驱关系</h2><p><img src="/images/操作系统知识总览2.15.png" alt="操作系统知识总览2.15"><br>一、信号量机制实现进程互斥<br>1、分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）<br>2、设置互斥信号量mutex，初值为1.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//信号量机制实现互斥</span><br><span class="line">semaphore mutex = 1;//初始化信号量</span><br><span class="line">//要会自己定义记录型信号量，但如果题目中没有特别说明，可以把信号量的声明简写成这种形式。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">P1</span></span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(mutex);//使用临界资源前需要加锁</span><br><span class="line">    临界区代码段...</span><br><span class="line">    V(mutex);//使用临界区资源后需要解锁</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">P2</span></span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(mutex);</span><br><span class="line">    临界区代码段...</span><br><span class="line">    V(mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在临界区之前执行P(mutex)。<br>4、在临界区之后执行V(mutex)。<br>5、对不同的临界资源需要设置不同的互斥信号量。<br>6、P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永远不被释放，等待进程永远不会被唤醒。<br>二、信号量机制实现进程同步<br>若P2的“代码4”要基于P1的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行。这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。<br>用信号量实现进程同步：<br>1、分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）<br>2、设置同步信号量S，初始为0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//信号量机制实现同步</span><br><span class="line">semaphore S = 0;//初始化同步信号量，初始化值为0</span><br></pre></td></tr></table></figure>
<p>3、在“前操作”之后执行V（S）。<br>4、在“后操作”之前执行P（S）。P是申请资源的那个操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">P1</span></span>()&#123;</span><br><span class="line">    代码1;</span><br><span class="line">    代码2;</span><br><span class="line">    V(S);</span><br><span class="line">    代码3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">P2</span></span>()&#123;</span><br><span class="line">    P(S);</span><br><span class="line">    代码4;</span><br><span class="line">    代码5;</span><br><span class="line">    代码6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若先执行到V(S)操作，则S++后S = 1。之后当执行到P(S)操作时，由于S = 1，表示有可用资源，会执行S—，S的值变回0，P2进程不会执行block原语，而是继续往下执行代码4。<br>若先执行到P(S)操作，由于S = 0，S—后S = -1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后执行完代码２，继而执行V(S)操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了。<br>三、信号量机制实现前驱关系<br>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作），因此：<br>1、要为每一对前驱关系各设置一个同步变量。<br>2、在“前操作”之后对相应的同步变量执行V操作。<br>3、在“后操作”之前对相应的同步变量执行P操作。<br><img src="/images/操作系统知识回顾2.15.png" alt="操作系统知识回顾2.15"></p>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>一、问题描述<br>1、系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）。<br>2、生产者、消费者共享一个初始为空，大小为n（若n = 5）的缓冲区。<br><img src="/images/操作系统问题描述2.16.png" alt="操作系统问题描述2.16"><br>3、只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。<br>4、只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。<br>5、缓冲区是临界资源，各进程必须互斥地访问。<br>6、信号量机制可实现：<br>互斥：设置初值为1的互斥信号量。<br>同步：设置初值为0的同步信号量，实现“一前一后”。<br>对一类系统资源的申请和释放：设置一个信号量，初始值即为资源的数量。本质上也属于“同步问题”，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行。<br>7、PV操作题目分析步骤：<br>1）关系分析。找出题目描述的各个进程，分析它们之间的同步、互斥关系。<br>生产者每次要消耗（P）一个空闲缓冲区，并生产（V）一个产品。消费者每次要消耗（P）一个产品，并释放（V）一个空闲缓冲区。往缓冲区放入/取走产品需要互斥。<br>2）整理思路。根据各进程的操作流程确定P、V操作的大致顺序。<br>3）设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;//互斥信号量，实现对缓冲区的互斥访问</span><br><span class="line">semaphore empty = n;//同步信号量，表示空闲缓冲区的数量</span><br><span class="line">semaphore full = 0;//同步信号量，表示产品的数量，也即非空缓冲区的数量</span><br></pre></td></tr></table></figure>
<p>二、如何实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(empty);//消耗一个空闲缓冲区</span><br><span class="line">        P(mutex);//实现互斥是在同一进程中进行一对PV操作</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);//增加一个产品</span><br><span class="line">        //实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">consumer</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(full);//消耗一个产品（非空缓冲区）</span><br><span class="line">        P(mutex);</span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);//增加一个空闲缓冲区</span><br><span class="line">        使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/操作系统如何实现2.16.png" alt="操作系统如何实现2.16"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(mutex);(1)//mutex的P操作在P(empty)之前</span><br><span class="line">        P(empty);(2)</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">consumer</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(mutex);(3)</span><br><span class="line">        P(full);(4)</span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);//增加一个空闲缓冲区</span><br><span class="line">        使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、若此时缓冲区内已经放满产品，则empty = 0，full = n。<br>则生产者进程执行(1)使mutex变为0，再执行(2),由于已没有空闲缓冲区，因此生产者被阻塞。<br>由于生产者阻塞，因此切换回消费者进程。消费者进程执行(3),由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。<br>这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。<br>2、同样的，若缓冲区中没有产品，即full = 0，empty = n。按(3)(4)(1)的顺序执行就会发生死锁。<br>3、因此,实现互斥的P操作一定要在实现同步的P操作之后。<br>4、V操作不会导致进程阻塞，因此两个V操作顺序可以交换。<br>三、知识回顾与重要考点<br>1、生产者消费者问题是一个互斥、同步的综合问题。<br>2、对于初学者来说最难的是发现题目中隐含的两对同步关系。有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，者是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。<br><img src="/images/操作系统知识回顾2.16.png" alt="操作系统知识回顾2.16"><br>3、易错点：实现互斥和实现同步的两个P操作的先后顺序。</p>
<h2 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h2><p>一、问题分析<br><img src="/images/操作系统问题分析2.17.png" alt="操作系统问题分析2.17"><br>二、如何实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;//实现互斥访问盘子（缓冲区）</span><br><span class="line">semaphore apple = 0;//盘子中有几个苹果</span><br><span class="line">semaphore orange = 0;//盘子中有几个橘子</span><br><span class="line">semaphore plate = 1;//盘子中还可以放多少水果</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dad</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        准备一个苹果;</span><br><span class="line">        P(plate);//检查盘子中是否可以放入水果</span><br><span class="line">        P(mutex);</span><br><span class="line">        把苹果放入盘子;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(apple);//告诉女儿进程盘子中的苹果数加一了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">mom</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        准备一个橘子;</span><br><span class="line">        P(plate);</span><br><span class="line">        P(mutex);</span><br><span class="line">        把橘子放入盘子;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">daughter</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(apple);//检查盘子中是否已经有自己需要的水果</span><br><span class="line">        P(mutex);</span><br><span class="line">        从盘中取出苹果;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);//告诉父亲和母亲进程盘子中已经空了</span><br><span class="line">        吃掉苹果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">son</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(orange);</span><br><span class="line">        P(mutex);</span><br><span class="line">        从盘中取出橘子;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);</span><br><span class="line">        吃掉橘子;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、可以不用互斥信号量mutex。同时把上述代码中对mutex的P、V操作全部去掉。根据过程分析即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。<br>2、原因在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1.因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。<br>3、如果盘子的容量为2的话，父亲在往盘子里放苹果，同时母亲也可以往盘子里放橘子。于是就出现了两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。<br>4、因此，如果缓冲区大小大于1，就必须专门设置一个互斥信号量mutex来保证互斥访问缓冲区。<br>三、知识回顾<br>1、在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。<br>2、在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。<br>3、解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。<br>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。</p>
<h2 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h2><p>一、问题分析<br><img src="/images/操作系统问题分析2.18.png" alt="操作系统问题分析2.18"><br>二、如何实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = 0;//桌上组合一的数量</span><br><span class="line">semaphore offer2 = 0;//桌上组合二的数量</span><br><span class="line">semaphore offer3 = 0;//桌上组合三的数量</span><br><span class="line">semaphore finish = 0;//抽烟是否完成</span><br><span class="line">int i = 0;//用于实现“三个抽烟者轮流抽烟”</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">provider</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == 0)&#123;</span><br><span class="line">            将组合一放桌上；</span><br><span class="line">            V(offer1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == 1)&#123;</span><br><span class="line">            将组合二放桌上；</span><br><span class="line">            V(offer2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == 2)&#123;</span><br><span class="line">            将组合三放桌上；</span><br><span class="line">            V(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+3)%3;</span><br><span class="line">        P(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">smoker1</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        从桌上拿走组合一；卷烟；抽掉；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">smoker2</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        从桌上拿走组合二；卷烟；抽掉；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">smoker3</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        从桌上拿走组合三；卷烟；抽掉；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、缓冲区大小为1，同一时刻，四个同步信号量中至多有一个的值为1。<br>三、知识回顾<br>1、吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题提供一个思路。<br>2、值得吸取的精华是：“轮流让各个吸烟者吸烟”必然需要“轮流的在桌上放组合一、二、三”，注意体会我们是如何用一个整型变量i实现这个“轮流”过程的。</p>
<p>3若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置。</p>
<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者 写者问题"></a>读者 写者问题</h2><p>一、问题描述<br>1、有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：<br>1）允许多个读者可以同时对文件执行读操作；<br>2）只允许一个写者往文件中写信息；<br>3）任一写者在完成写操作之前不允许其他读者或写者工作；<br>4）写者执行写操作前，应让已有的读者和写者全部退出。<br>2、与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者可同时访问共享数据。<br>二、问题分析<br>1、两类进程：写进程、读进程<br>互斥关系：写进程-写进程、写进程-读进程。读进程与读进程不存在互斥问题。<br>2、写者进程和任何进程都要互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。<br>3、读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。<br>4、如果所有读者进程在访问共享文件之前都执行P(rw)操作，那么会导致各个读进程之间也无法同时访问文件。Key：读者写者问题的核心思想—怎么处理该问题呢？<br>5、P(rw)和V(rw)其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读进程“解锁”。可以设置一个整数变量count来记录当前有几个读进程在访问文件。<br>三、如何实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = 1;//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span><br><span class="line">int count = 0;//记录当前有几个读进程在访问文件</span><br><span class="line">semaphore mutex = 1;//用于保证对count变量的互斥访问</span><br><span class="line">semaphore w = 1;//用于实现“写优先”</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">writer</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(rw);//写之前“加锁”</span><br><span class="line">        写文件...</span><br><span class="line">        V(rw);//写之后“解锁”</span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">reader</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(mutex);//各读进程互斥访问count</span><br><span class="line">        <span class="keyword">if</span>(count == 0)&#123;</span><br><span class="line">            P(rw);//第一个读进程负责“加锁”</span><br><span class="line">        &#125;</span><br><span class="line">        count++;//访问文件的读进程数+1</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        读文件...</span><br><span class="line">        P(mutex);//各读进程互斥访问count</span><br><span class="line">        count--;//访问文件的读进程数-1</span><br><span class="line">        <span class="keyword">if</span>(count == 0)&#123;</span><br><span class="line">            V(rw);//最后一个读进程负责“解锁”</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、若两个读进程并发执行，则两个读进程有可能先后执行P(rw),从而使第二个读进程阻塞的情况。<br>如何解决：出现上述问题的原因在于对count变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量mutex来保证各读进程对count的访问是互斥的。<br>2、潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的。<br>如何解决：设置一个信号量w用于实现“写优先”。<br>效果：在有写者进程被阻塞的情况下，不允许有新的读者进程读文件。<br>3、结论：在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。<br>有的书上把这种算法称为“读写公平法”。<br>四、知识回顾与重要考点<br>1、读者写者问题的核心思想在于设置了一个计数器count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。<br>2、另外，对count变量的检查和赋值不能一气呵成导致了一些错误，但如果需要实现“一气呵成”，自然应该想到利用互斥信号量。<br>3、绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决。</p>
<h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>一、问题描述<br><img src="/images/操作系统问题描述2.19.png" alt="操作系统问题描述2.19"><br>二、问题分析</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1,1,1,1,1&#125;;</span><br><span class="line"><span class="function"><span class="title">Pi</span></span>()&#123;//i号哲学家的进程</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(chopstick[i]);//拿左</span><br><span class="line">        P(chopstick[(i+1)%5]);//拿右</span><br><span class="line">        吃饭...</span><br><span class="line">        V(chopstick[i]);//放左</span><br><span class="line">        V(chopstick[(i+1)%5]);//放右</span><br><span class="line">        思考...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、每位哲学家拿起自己面前的一只筷子，每位哲学家循环等待右边的人放下筷子（阻塞）。发生死锁<br>三、如何实现<br>1、如何防止死锁的发生呢？<br>1）可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。<br>2）要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么就只会有其中一个可以拿起第一只筷子，另一个会直接阻塞，这就避免了占有一支后再等待另一只的情况。<br>3)仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。更准确的说法应该是：各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1,1,1,1,1&#125;;</span><br><span class="line">semaphore mutex = 1;//互斥地取筷子</span><br><span class="line"><span class="function"><span class="title">Pi</span></span>()&#123;//i号哲学家的进程</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);//拿左</span><br><span class="line">        P(chopstick[(i+1)%5]);//拿右</span><br><span class="line">        V(mutex);</span><br><span class="line">        吃饭...</span><br><span class="line">        V(chopstick[i])//放左</span><br><span class="line">        V(chopstick[(i+1)%5]);//放右</span><br><span class="line">        思考...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四、知识回顾与重要考点<br>1、哲学家进餐问题的关键在于解决死锁。<br>2、这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。<br>3、如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p><img src="/images/操作系统知识总览2.20.png" alt="操作系统知识总览2.20"><br>一、管程的定义和基本特征<br>1、管程是一种特殊的软件模块，由这些部分组成<br>1）局部于管程的共享数据结构说明；<br>2）对该数据结构进行操作的一组过程；（函数）<br>3）对局部于管程的共享数据设置初始值的语句；<br>4）管程有一个名字。<br>2、管程的基本特征：<br>1）局部于管程的数据只能被局部于管程的过程所访问。<br>2）一个进程只有通过调用管程内的过程才能进入管程访问共享数据；<br>3）每次仅允许一个进程在管程内执行某个内部过程。<br>二、用管程解决生产者消费者问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">condition full,empty;//条件变量用来实现同步（排队）</span><br><span class="line">int count = 0;//缓冲区中的产品数</span><br><span class="line">void insert(Item item)&#123;//把产品item放入缓冲区</span><br><span class="line">    <span class="keyword">if</span>(count == N)&#123;</span><br><span class="line">        <span class="built_in">wait</span>(full);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="keyword">if</span>(count == 1)&#123;</span><br><span class="line">        signal(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Item <span class="function"><span class="title">remove</span></span>()&#123;//从缓冲区中取出一个产品</span><br><span class="line">    <span class="keyword">if</span>(count == 0)&#123;</span><br><span class="line">        <span class="built_in">wait</span>(empty);</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count == N-1)&#123;</span><br><span class="line">        signal(full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> remove_item();</span><br><span class="line">&#125;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line">//生产者进程</span><br><span class="line"><span class="function"><span class="title">producer</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        item = 生产一个产品;</span><br><span class="line">        ProdecerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//消费者进程</span><br><span class="line"><span class="function"><span class="title">consumer</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        item = ProdecerConsumer.remove();</span><br><span class="line">        消费产品item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、item-由编译器负责实现各进程互斥地进入管程中的过程。每次仅允许一个进程在管程内执行某个内部过程。例如两个生产者进程并发执行，依次调用了insert过程……<br>2、管程中设置条件变量和等待/唤醒操作，以解决同步问题。<br>3、引入管程的目的无非就是要更方便地实现进程互斥和同步。<br>4、需要在管程中定义共享数据（如生产者消费者问题地缓冲区）。<br>5、需要在管程中定义用于访问这些共享数据地”入口“—其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）。<br>6、只有通过这些特定的“入口”才能访问共享数据。<br>7、管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的，程序员不用关心）。<br>8、可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。<br>9、程序员可以用某种特殊的语法定义一个管程（比如：monitor ProducerConsumer……end monitor），之后其他程序员就可以使用这个管程提供的特定“入口”很方便地实现进程同步/互斥了。<br>三、Java中类似于管程的机制<br>1、Java中，如果用关键字synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class monitor&#123;</span><br><span class="line">    private Item buffer[] = new Item[N];</span><br><span class="line">    private int count = 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void insert(Item item)&#123;</span><br><span class="line">        //每次只能有一个线程进入insert函数，如果多个线程同时调用insert函数，则后来者需要排队等待</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/操作系统知识回顾2.20.png" alt="操作系统知识回顾2.20"></p>
<h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><p><img src="/images/操作系统知识总览2.21.png" alt="操作系统知识总览2.21"><br>一、什么是死锁<br>1、每位哲学家都在等待自己右边的人放下筷子，这些哲学家进程都因等待筷子资源而被阻塞。即发生“死锁”。<br>2、每个人都占有一个资源，同时又在等待另一个人手里的资源。发生“死锁”。<br>3、在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进。<br>二、死锁、饥饿、死循环的区别<br>1、死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。<br>2、饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。<br>3、死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。<br><img src="/images/操作系统死锁饥饿死循环2.21.png" alt="操作系统死锁饥饿死循环2.21"><br>三、死锁产生的必要条件<br>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。<br>1、互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。<br>2、不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。<br>3、请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。<br>4、循环等待条件：存在一种进程资源的循环等待链，链中的每个进程已获得的资源同时被下一个进程所请求。<br>5、注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁。（循环等待是死锁的必要不充分条件）<br>6、如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。<br>四、什么时候会发生死锁<br>1、对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。<br>2、进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。<br>3、信号量使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能造成死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）<br>4、总之，对不可剥夺资源的不合理分配，可能导致死锁。<br>五、死锁的处理策略<br>1、预防死锁。破坏死锁产生的四个必要条件中的一个或几个。<br>2、避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。<br>3、死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。<br><img src="/images/操作系统知识回顾2.21.png" alt="操作系统知识回顾2.21"></p>
<h2 id="死锁的处理策略-预防死锁"><a href="#死锁的处理策略-预防死锁" class="headerlink" title="死锁的处理策略-预防死锁"></a>死锁的处理策略-预防死锁</h2><p><img src="/images/操作系统知识总览2.22.png" alt="操作系统知识总览2.22"><br>一、破坏互斥条件<br>1、互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。<br>2、如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术。<br>3、操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOling技术将打印机改造为共享设备…<br>4、该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。<br>二、破坏不剥夺条件<br>1、不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。<br>2、方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。<br>3、方案二：当某个进程需要的资源被其他进程占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）<br>4、该策略的缺点：<br>1）实现起来比较复杂。<br>2）释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。<br>3）反复地申请和释放资源会增加系统开销，降低系统吞吐量。<br>4）若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源都需要放弃，以后再重新申请。如果一直发生这种情况，就会导致进程饥饿。<br>三、破坏请求和保持条件<br>1、请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。<br>2、可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源一直归它所有，该进程就不会再请求别的任何资源了。<br>3、该策略实现起来简单，但也有明显的缺点：<br>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。<br>四、破坏循环等待条件<br>1、循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。<br>2、可采用顺序分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。<br>3、原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号资源，从而就不会产生循环等待的现象。<br>4、在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。因此，不可能出现所有进程都阻塞的死锁现象。<br>5、该策略的缺点：<br>1）不方便增加新的设备，因为可能需要重新分配所有的编号。<br>2）进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费。<br>3）必须按照规定次序申请资源，用户编程麻烦。<br><img src="/images/操作系统知识回顾2.22.png" alt="操作系统知识回顾2.22"></p>
<h2 id="死锁的处理策略-避免死锁"><a href="#死锁的处理策略-避免死锁" class="headerlink" title="死锁的处理策略-避免死锁"></a>死锁的处理策略-避免死锁</h2><p><img src="/images/操作系统知识总览2.23.png" alt="操作系统知识总览2.23"><br>一、安全序列、不安全状态、死锁的联系<br>1、所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。<br>2、如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。<br>3、如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）。<br>4、因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。<br>二、银行家算法<br>1、银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁。<br>2、核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这些请求，让该进程先阻塞等待。<br>3、将所有进程都加入安全序列中，最终可得一个安全序列。该算法称为安全性算法。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。实际做题时可以更快速的得到安全序列。<br>4、假设系统中有n个进程，m种资源。每个进程在运行前先声明对各种资源的最大需求数，则可用一个n<em>m的矩阵（可用二维数组实现）表示所有进程对各种资源的最大需求数。不妨称为最大需求矩阵Maz，Max[i,j] = k表示进程Pi最多需要k个资源Rj。同理，系统可以用一个n</em>m的分配矩阵Allocation表示对所有进程的资源分配情况。Max-Allocation = Need矩阵，表示各进程最多还需要多少各类资源。<br>5、另外还要用一个长度为m的一位数组$Request_i$表示本次申请的各种资源量。<br>6、可用银行家算法预判本次分配是否会导致系统进入不安全状态：<br>1）如果$Request_i[j] \leqslant Need<a href="0 \leqslant j \leqslant m">i,j</a>$便转向（2）；否则认为出错。因为它所需要的资源数已超过它所宣布的最大值。<br>2）如果$Request_i[j] \leqslant Available<a href="0 \leqslant j \leqslant m">j</a>$便转向（3）；否则表示尚无足够资源，Pi必须等待。<br>3）系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）；<br>Available = Available - $Request_i;$<br>Allocation[i,j] = Allocation[i,j] + $Request_i[j];$<br>Need[i,j] = Need[i,j] - $Request_i[j];$<br>4）操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正是分配；否则，恢复相应数据，让进程阻塞等待。<br>三、知识回顾与重要考点<br>1、数据结构：<br>1）长度为m的一维数组Available表示还有多少可用资源；<br>2）n<em>m矩阵Max表示各进程对资源的最大需求数；<br>3）n</em>m矩阵Allocation表示已经给进程分配了多少资源；<br>4）Max - Allocation = Need矩阵表示各进程最多还需要多少资源；<br>5）用长度为m的一维数组Request表示进程此次申请的各种资源数。<br>2、银行家算法步骤：<br>1）检查此次申请是否超过了之前声明的最大需求数。<br>2）检查此时系统剩余的可用资源数是否还能满足这次请求。<br>3）试探着分配，更改各种数据结构。<br>4）用安全性算法检查此次分配是否会导致系统进入不安全状态。<br>3、安全性算法步骤：<br>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。<br>不断重复上述过程，看最终是否能让所有进程都加入安全序列。<br>4、系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。</p>
<h2 id="死锁的处理策略-检测和解除"><a href="#死锁的处理策略-检测和解除" class="headerlink" title="死锁的处理策略-检测和解除"></a>死锁的处理策略-检测和解除</h2><p><img src="/images/操作系统知识总览2.24.png" alt="操作系统知识总览2.24"><br>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：<br>1）死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。<br>2）死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。<br>一、死锁的检测<br>1、为了能对系统是否已发生了死锁进行检测，必须：<br>1）用某种数据结构来保存资源的请求和分配信息。<br>2）提供一种算法，利用上述信息来检测系统是否已进入死锁状态。<br><img src="/images/操作系统资源分配图2.24.png" alt="操作系统资源分配图2.24"><br>注意：<br>一般用矩形表示资源结点，矩形中的小圆代表该类资源的数量。<br>2、如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。<br>3、如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。<br>4、相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…<br>5、如果按照上述分析，最终能消除所有边，就称这个图是可完全化简得。此时一定没有发生死锁（相当于能找到一个安全序列）。<br>6、如果最终不能消除所有边，那么此时就是发生了死锁。<br>7、最终还连着边得那些进程就是处于死锁状态得进程。<br>8、死锁检测得算法：<br>在资源分配图中，找出既不阻塞又不是孤点的进程$P_i$(即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源)。消去它所有的请求边和分配边，使之成为孤立的节点。<br>进程$P_i$所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。若能消去图中所有的边，则称该图是可完全化简的。<br>9、死锁定理：如果某时刻系统的资源分配图是不可完全化简的，那么此时系统死锁。<br>二、死锁的解除<br>1、一旦检测出死锁的发生，就应该立即解除死锁。<br>注意：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程。<br>2、解除死锁的主要方法有：<br>1）资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。<br>2）撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。<br>3）进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。<br><img src="/images/操作系统知识回顾2.24.png" alt="操作系统知识回顾2.24"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/21/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%BB%84%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/" rel="prev" title="数据的表示和运算">
      <i class="fa fa-chevron-left"></i> 数据的表示和运算
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/27/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E4%BA%8C/" rel="next" title="计算机网络王道二">
      计算机网络王道二 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的定义、组成、组织方式、特征"><span class="nav-number">1.</span> <span class="nav-text">进程的定义、组成、组织方式、特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的状态与转换"><span class="nav-number">2.</span> <span class="nav-text">进程的状态与转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制"><span class="nav-number">3.</span> <span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程通信"><span class="nav-number">4.</span> <span class="nav-text">进程通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程概念多线程模型"><span class="nav-number">5.</span> <span class="nav-text">线程概念多线程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理机调度概念、层次"><span class="nav-number">6.</span> <span class="nav-text">处理机调度概念、层次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程调度的时机、切换与过程、调度方式"><span class="nav-number">7.</span> <span class="nav-text">进程调度的时机、切换与过程、调度方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度算法的评价指标"><span class="nav-number">8.</span> <span class="nav-text">调度算法的评价指标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度算法-先来先服务、最短作业优先、最高响应比优先"><span class="nav-number">9.</span> <span class="nav-text">调度算法 先来先服务、最短作业优先、最高响应比优先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度算法-时间片轮转-优先级调度-多级反馈队列"><span class="nav-number">10.</span> <span class="nav-text">调度算法 时间片轮转 优先级调度 多级反馈队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程同步-进程互斥"><span class="nav-number">11.</span> <span class="nav-text">进程同步 进程互斥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程互斥的软件实现方法"><span class="nav-number">12.</span> <span class="nav-text">进程互斥的软件实现方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程互斥的硬件实现方法"><span class="nav-number">13.</span> <span class="nav-text">进程互斥的硬件实现方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量机制"><span class="nav-number">14.</span> <span class="nav-text">信号量机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用信号量机制实现进程互斥、同步、前驱关系"><span class="nav-number">15.</span> <span class="nav-text">用信号量机制实现进程互斥、同步、前驱关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者消费者问题"><span class="nav-number">16.</span> <span class="nav-text">生产者消费者问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多生产者-多消费者问题"><span class="nav-number">17.</span> <span class="nav-text">多生产者-多消费者问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#吸烟者问题"><span class="nav-number">18.</span> <span class="nav-text">吸烟者问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读者-写者问题"><span class="nav-number">19.</span> <span class="nav-text">读者 写者问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哲学家进餐问题"><span class="nav-number">20.</span> <span class="nav-text">哲学家进餐问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管程"><span class="nav-number">21.</span> <span class="nav-text">管程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁的概念"><span class="nav-number">22.</span> <span class="nav-text">死锁的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁的处理策略-预防死锁"><span class="nav-number">23.</span> <span class="nav-text">死锁的处理策略-预防死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁的处理策略-避免死锁"><span class="nav-number">24.</span> <span class="nav-text">死锁的处理策略-避免死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁的处理策略-检测和解除"><span class="nav-number">25.</span> <span class="nav-text">死锁的处理策略-检测和解除</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Monica</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Monica</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
