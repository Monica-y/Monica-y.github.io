<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"monica-y.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="期末复习代码整理">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构算法整理">
<meta property="og:url" content="https://monica-y.github.io/2020/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="期末复习代码整理">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-21T02:45:21.364Z">
<meta property="article:modified_time" content="2020-12-29T02:09:03.223Z">
<meta property="article:author" content="Monica">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://monica-y.github.io/2020/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构算法整理 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://monica-y.github.io/2020/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Monica">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构算法整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-21 10:45:21" itemprop="dateCreated datePublished" datetime="2020-12-21T10:45:21+08:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-29 10:09:03" itemprop="dateModified" datetime="2020-12-29T10:09:03+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          
            <div class="post-description">期末复习代码整理</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>稳定的排序算法<br>题目：用插入排序对一组数据排序。<br>问题描述：<br>输入一个长度为n(3&lt;n&lt;100)的整数数组，实现用插入排序对数组中的元素排序，并输出前三趟排序后的数据。<br>输入格式:<br>   首先输入串的长度n，然后输入整数数组n.<br>输出格式:<br>   在三行上输出前三趟插入排序后的数组。<br>样例输入:<br> 8<br> 17 46 32 87 58 9 50 38<br>样例输出:<br>17 46 32 87 58 9 50 38<br>17 32 46 87 58 9 50 38<br>17 32 46 87 58 9 50 38</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int number_size;</span><br><span class="line"> int data[105];</span><br><span class="line"> cin &gt;&gt; number_size;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= number_size; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin &gt;&gt; data[i];</span><br><span class="line"> &#125;</span><br><span class="line"> int temp = 0;</span><br><span class="line"> <span class="keyword">for</span> (int i = 2; i &lt;= 4; i++)//如果要完整排完只需要将i的出循环条件设置为i&lt;=number_size即可</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span> (int j = 1; j &lt; i; j++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span> (data[j] &gt; data[i])</span><br><span class="line">   &#123;</span><br><span class="line">    temp = data[j];</span><br><span class="line">    data[j] = data[i];</span><br><span class="line">    <span class="keyword">for</span> (int x = i; x &gt; j+1; x--)</span><br><span class="line">    &#123;</span><br><span class="line">     data[x] = data[x - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    data[j + 1] = temp;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (int i = 1; i &lt;= number_size; i++)</span><br><span class="line">  &#123;</span><br><span class="line">   cout &lt;&lt; data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>不稳定的排序方法<br>题目：用希尔排序对一组数据排序。<br>问题描述：<br> 输入一个长度为n（n&lt;100）的整数数组，并实现用希尔排序对数组中的元素排序，输出第一趟排序后的数据。(希尔排序中的增量设置为increment=n/2向下取整，increment=increment/2向下取整，直到increment=1)<br>输入格式:<br>  首先输入串的长度n，然后输入整数数组.<br>输出格式:<br>  输出第一趟希尔排序后的数组。<br>样例输入:<br>8<br>48 26 66 57 32 85 55 19<br>样例输出:<br>32 26 55 19 48 85 66 57<br>将每个分组的元素都记录在vector中,然后用sort排完序之后又放回到原数组中,注意每排一次都要清空vector.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int input[105];</span><br><span class="line">int number_size;</span><br><span class="line">vector&lt;int&gt;vec;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin &gt;&gt; number_size;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= number_size; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin &gt;&gt; input[i];</span><br><span class="line"> &#125;</span><br><span class="line"> int gap = number_size / 2;//如果要完整排完只需要再加一个循环使得gap减到1就可以了</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= gap; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span> (int j = 0; j &lt; number_size / gap; j++)//注意这里j的出循环条件</span><br><span class="line">  &#123;</span><br><span class="line">   vec.push_back(input[i + j * gap]);</span><br><span class="line">  &#125;</span><br><span class="line">  sort(vec.begin(), vec.end());</span><br><span class="line">  int cnt = 0;</span><br><span class="line">  <span class="keyword">for</span> (int j = 0; j &lt; number_size / gap; j++)</span><br><span class="line">  &#123;</span><br><span class="line">   input[i + j * gap] = vec[cnt++];</span><br><span class="line">  &#125;</span><br><span class="line">  vec.clear();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= number_size; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; input[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>不稳定的排序方法<br>题目：快速排序<br>问题描述<br>采用快速排序算法，排序输入的n个整数，prvotkey（枢轴）每次选取数组第一个数。<br>输出快速排序第一趟排序的结果。<br>输入格式<br> 输入的第一行包括一个整数n(1&lt;=n&lt;=100)。<br>接下来的一行包括n个整数，空格隔开。<br>输出格式<br> 按照要求排序后输出，由空格分隔。<br>样例输入<br>9<br>50 10 90 30 70 40 80 60 20<br>样例输出<br>20 10 40 30 50 70 80 60 90</p>
<p>算法简述：首先任意选取一个记录（通常可选第一个记录）作为枢轴（pivot），然后按下述原则重新排列其余记录：<br>附设两个指针low和high，它们的初值分别为low和high，设枢轴记录的关键字为pivotkey，则首先从high所指的位置起向前搜索找到第一个关键字小于pivotkey的记录和枢轴记录相交换，然后从low所指位置起向后搜索，找到第一个关键字大于pivotkey的记录和枢轴记录相互交换，重复这两步直到low == high为止。<br>其实就是从high所指的位置起向前搜索找到第一个关键字小于pivotkey的记录，直接放到原来pivotkey元素所在的数组位置，等到一趟排序结束后，再把pivotkey元素填入到空缺的位置上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int number_size;</span><br><span class="line">int input[105];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin &gt;&gt; number_size;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= number_size; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin &gt;&gt; input[i];</span><br><span class="line"> &#125;</span><br><span class="line"> int pivot = input[1];</span><br><span class="line"> int low = 1;</span><br><span class="line"> int high = number_size;</span><br><span class="line"> <span class="keyword">while</span> (low &lt; high)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">while</span> (low&lt;high &amp;&amp; input[high]&gt;=pivot)//一定是&gt;=而不是＞，书上快排算法就是这样实现的</span><br><span class="line">   high--;</span><br><span class="line">  input[low] = input[high];</span><br><span class="line">  <span class="keyword">while</span> (low &lt; high &amp;&amp; input[low] &lt;= pivot)</span><br><span class="line">   low++;</span><br><span class="line">  input[high] = input[low];</span><br><span class="line"> &#125;</span><br><span class="line"> input[low] = pivot;//此时low == high;</span><br><span class="line"> //QSort(1,low-1);</span><br><span class="line"> //QSort(low+1,number_size);</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= number_size; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; input[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line"> //如果要完整排完则要将<span class="keyword">while</span>循环放在QSort函数中，然后枢轴左右递归调用，见<span class="keyword">while</span>下的注释。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>不稳定的排序方法<br>堆排序<br>题目描述：编写堆排序算法，建立小顶堆，测试数据为整数。</p>
<p>输入：<br>第一行是待排序数据元素的个数（小于100）； 第二行是待排序的数据元素。</p>
<p>输出：<br>建立小顶堆的结果。</p>
<p>样例输入：<br>10<br>50 36 41 19 23 4 20 18 12 22</p>
<p>样例输出：<br>4 12 20 18 22 41 50 36 19 23</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;functional&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt;vec;</span><br><span class="line">int number_size;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int value;</span><br><span class="line"> cin &gt;&gt; number_size;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= number_size; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin &gt;&gt; value;</span><br><span class="line">  vec.push_back(value);</span><br><span class="line"> &#125;</span><br><span class="line"> make_heap(vec.begin(), vec.end(), greater&lt;int&gt;());//小顶堆，默认是大顶堆，别忘记functional头文件</span><br><span class="line"> <span class="keyword">for</span> (int i = 0; i &lt; number_size; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>稳定的排序方法<br>题目：归并排序<br>问题描述<br>采用归并排序的方式，将两个已排序的数组，合并为一个数组并输出。<br>输入格式<br> 输入第一行包含M N两个数，分别是第一和第二两个数组长度，空格分隔。M&lt;100,N&lt;100。<br>第二行为第一个已排序的数组，空格分隔<br>第三行为第二个已排序的数组，空格分隔<br>输出格式<br> 输出排序好的从小到大数组，空格分隔<br>样例输入<br> 4 4<br>1 2 3 4<br>2 3 4 5<br>样例输出<br> 1 2 2 3 3 4 4 5</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt;vec;</span><br><span class="line">int input1[105];</span><br><span class="line">int input2[105];</span><br><span class="line">int number_size1, number_size2;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin &gt;&gt; number_size1&gt;&gt;number_size2;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= number_size1; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin &gt;&gt; input1[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= number_size2; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin &gt;&gt; input2[i];</span><br><span class="line"> &#125;</span><br><span class="line"> vec.resize(number_size1 + number_size2);//一定要给vec分配内存，否则会报错。</span><br><span class="line"> merge(&amp;input1[1], &amp;input1[number_size1+1], &amp;input2[1], &amp;input2[number_size2+1], vec.begin());//第二个参数和第四个参数一定是最后一个元素的后一个位置</span><br><span class="line"> <span class="keyword">for</span> (int i = 0; i &lt; number_size1+number_size2; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>题目描述<br>DL 算缘分算得很烦闷，所以常常到体育馆去打保龄球解闷。因为他保龄球已经打了几十年了，所以技术上不成问题，于是他就想玩点新花招。</p>
<p>DL 的视力真的很不错，竟然能够数清楚在他前方十米左右每个位置的瓶子的数量。他突然发现这是一个炫耀自己好视力的借口——他看清远方瓶子的个数后从某个位置发球，这样就能打倒一定数量的瓶子。</p>
<p>1 OOO</p>
<p>2 OOOO</p>
<p>3 O</p>
<p>4 OO</p>
<p>如上图，每个“O”代表一个瓶子。如果 DL 想要打倒 3 个瓶子就在 1 位置发球，想要打倒 4 个瓶子就在 2 位置发球。</p>
<p>现在他想要打倒 m 个瓶子。他告诉你每个位置的瓶子数，请你给他一个发球位置。</p>
<p>输入格式<br>输入文件名为 bowling.in。</p>
<p>第一行包含一个正整数 n，表示位置数。</p>
<p>第二行包含 n 个正整数，第 i 个数。表示第 i 个位置的瓶子数，保证各个位置的瓶子数不同。</p>
<p>第三行包含一个正整数 Q，表示 DL 发球的次数。</p>
<p>第四行至文件末尾，每行包含一个正整数 m，表示 DL 需要打倒 m 个瓶子。</p>
<p>输出格式<br>输出文件名为 bowling.out。</p>
<p>共 Q 行。每行包含一个整数，第 i 行的整数表示 DL 第 i 次的发球位置。若无解，则输出 0。</p>
<p>输入输出样例<br>输入 #1复制<br>5<br>1 2 4 3 5<br>2<br>4<br>7<br>输出 #1复制<br>3<br>0<br>说明/提示<br>【数据范围】</p>
<p>对于 50%的数据，1 ≤ n,Q ≤ 1000，1 ≤ai,M ≤ 10^5</p>
<p>对于 100%的数据，1 ≤ n,Q ≤ 100000，1 ≤ai,M ≤ 10^9</p>
<p>题目来自洛谷<a href="https://www.luogu.com.cn/problem/P1918" target="_blank" rel="noopener">原题</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct Elem</span><br><span class="line">&#123;</span><br><span class="line"> int position;</span><br><span class="line"> int ball_number;</span><br><span class="line">&#125;;</span><br><span class="line">Elem elem[100005];</span><br><span class="line">int position, aim, <span class="built_in">times</span>;</span><br><span class="line">bool cmp(Elem&amp; a, Elem&amp; b)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">return</span> a.ball_number &lt; b.ball_number;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin &gt;&gt; position;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= position; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  elem[i].position = i;</span><br><span class="line">  cin &gt;&gt; elem[i].ball_number;</span><br><span class="line"> &#125;</span><br><span class="line"> sort(&amp;elem[1], &amp;elem[position+1], cmp);</span><br><span class="line"> /*<span class="keyword">for</span> (int i = 1; i &lt;= position; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; elem[i].position &lt;&lt; <span class="string">" "</span> &lt;&lt; elem[i].ball_number &lt;&lt; endl;</span><br><span class="line"> &#125;*/</span><br><span class="line"> cin &gt;&gt; <span class="built_in">times</span>;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= <span class="built_in">times</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin &gt;&gt; aim;</span><br><span class="line">  int left = 1;</span><br><span class="line">  int right = position;</span><br><span class="line">  int position_number = 0;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right)//注意这个循环条件不能没有等号</span><br><span class="line">  &#123;</span><br><span class="line">   int mid = (left + right)/ 2;</span><br><span class="line">   <span class="keyword">if</span> (aim == elem[mid].ball_number)</span><br><span class="line">   &#123;</span><br><span class="line">    position_number = mid;</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (aim &gt; elem[mid].ball_number)</span><br><span class="line">   &#123;</span><br><span class="line">    left = mid + 1;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (aim &lt; elem[mid].ball_number)</span><br><span class="line">   &#123;</span><br><span class="line">    right = mid - 1;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (position_number == 0)</span><br><span class="line">  &#123;</span><br><span class="line">   cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; elem[position_number].position &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分的左闭右开写法，首次接触左闭右开神教，和STL函数统一起来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct Elem</span><br><span class="line">&#123;</span><br><span class="line"> int position;</span><br><span class="line"> int ball_number;</span><br><span class="line">&#125;;</span><br><span class="line">Elem elem[100005];</span><br><span class="line">int position, aim, <span class="built_in">times</span>, position_number;</span><br><span class="line">bool cmp(Elem&amp; a, Elem&amp; b)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">return</span> a.ball_number &lt; b.ball_number;</span><br><span class="line">&#125;</span><br><span class="line">bool binary_search(int l, int r,int aim)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span> (r - 1 &gt;= l)//这里一定要有等号，否则退出循环的时候该区间内是两个元素</span><br><span class="line"> &#123;</span><br><span class="line">  int mid = l + (r - l) / 2;</span><br><span class="line">  <span class="keyword">if</span> (aim == elem[mid].ball_number)</span><br><span class="line">  &#123;</span><br><span class="line">   position_number = mid;</span><br><span class="line">   <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (aim &gt; elem[mid].ball_number)</span><br><span class="line">  &#123;</span><br><span class="line">   l = mid + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (aim &lt; elem[mid].ball_number)</span><br><span class="line">  &#123;</span><br><span class="line">   r = mid;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin &gt;&gt; position;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= position; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  elem[i].position = i;</span><br><span class="line">  cin &gt;&gt; elem[i].ball_number;</span><br><span class="line"> &#125;</span><br><span class="line"> sort(&amp;elem[1], &amp;elem[position+1], cmp);</span><br><span class="line"> cin &gt;&gt; <span class="built_in">times</span>;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= <span class="built_in">times</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin &gt;&gt; aim;</span><br><span class="line">  int left = 1;</span><br><span class="line">  int right = position + 1;//一定要注意是左开右闭模式，最开始的right值也应该在原基础上加一</span><br><span class="line">  <span class="keyword">if</span> (binary_search(left,right,aim))</span><br><span class="line">  &#123;</span><br><span class="line">   cout &lt;&lt; elem[position_number].position &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种写法显然是左闭右闭的模式，标志是left和right都能取到，所以在调整right是和left相对应，为mid-1；第二种写法是左闭右开的模式，标志是只有left点能取到，而right点只能取到它的前一个。所以在调整right时和left不相同，为mid,因为mid这一点取不到，所以实际上还是取到mid-1。<br>两种写法的right有所不同，循环的条件也对应不同。统一来讲就是都是保证left和right区间内只有一个元素，所以左闭右闭的写法中需要left == right，而左闭右开的写法中需要right-left == 1，这样right取不到，最终区间内就之后right一个元素。</p>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>该专题有一个专门的blog，请移步blog：二叉排序树。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>标题<br>哈希表<br>时间限制<br>2 S<br>内存限制<br>10000 Kb<br>问题描述：<br> 用除留余数法和线性探测再散列的冲突解决方法构造哈希表<br>输入：<br> 输入数据第一行为两个正整数分别为：哈希表表长m（m&lt;100）和除数p（p&lt;=m）。后面每一行是一个整数关键字，以-1作为输入的结束。<br>输出：<br>若输入的关键字在哈希表中已存在，则输出该关键字在哈希表中的位置，继续等待输入下一个关键字。<br>若输入的关键字在哈希表中不存在，则判断当前哈希表中关键字的个数是否等于m-1，若相等，则输出“Table full”，程序结束；否则将关键字插入哈希表，并输出该关键字插入在哈希表中的位置，继续等待输入下一个关键字。</p>
<p>示例输入：<br>5 3<br>1<br>2<br>3<br>4<br>5<br>-1<br>示例输出：<br>1<br>2<br>0<br>3<br>Table full</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="built_in">hash</span>[105];</span><br><span class="line">int mode, table_size;</span><br><span class="line">int key;</span><br><span class="line">int value;</span><br><span class="line">int now_size;</span><br><span class="line">map&lt;int, int&gt;M;</span><br><span class="line">void hash_search(int key)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span> (int i = 0; i &lt; table_size; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">hash</span>[i] == key)</span><br><span class="line">  &#123;</span><br><span class="line">   cout &lt;&lt; i &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">   <span class="built_in">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">void hash_function(int key)</span><br><span class="line">&#123;</span><br><span class="line"> value = key % mode;</span><br><span class="line"> <span class="keyword">if</span> (M[key])//一定要注意记录该元素是否在表中,否则就要使用逆着解决哈希冲突的方向查找元素,这里一旦发现该元素在表中直接遍历元素,降低程序了复杂度.</span><br><span class="line"> &#123;</span><br><span class="line">  hash_search(key);</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (now_size == table_size - 1)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">"Table full\n"</span>;</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (::<span class="built_in">hash</span>[value] != -1)</span><br><span class="line"> &#123;</span><br><span class="line">  value = (value + 1)%table_size;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> ::<span class="built_in">hash</span>[value] = key;</span><br><span class="line"> M[key]++;</span><br><span class="line"> now_size++;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span> (int i = 0; i &lt;= 104; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  ::<span class="built_in">hash</span>[i] = -1;</span><br><span class="line"> &#125;</span><br><span class="line"> cin &gt;&gt; table_size &gt;&gt; mode;</span><br><span class="line"> <span class="keyword">while</span> (1)</span><br><span class="line"> &#123;</span><br><span class="line">  cin &gt;&gt; key;</span><br><span class="line">  <span class="keyword">if</span> (key == -1)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  hash_function(key);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无向连通子图"><a href="#无向连通子图" class="headerlink" title="无向连通子图"></a>无向连通子图</h2><p>标题<br>求无向图连通子图<br>时间限制<br>2 S<br>内存限制<br>10000 Kb<br>问题描述<br>求无向图连通子图个数<br>问题输入<br>测试数据由m+1行构成，第一行为两个正整数n（1&lt;n&lt;=30）和m（1&lt;m&lt;100），分别表示顶点数（顶点编号为1,2,…,n）和边数，其后是m行数据，每行数据是一条边的信息，包括两个数字，分别表示该边关联的两个顶点。<br>问题输出<br>输出两行信息，第一行输出该图中连通子图的个数。第二行按照升序输出每个连通子图中顶点个数。<br>输入样例<br>9 8<br>1 2<br>1 3<br>2 4<br>3 4<br>5 7<br>5 6<br>6 7<br>8 9</p>
<p>输出样例<br>3<br>2 3 4</p>
<p>并查集+map记录出现的次数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;iterator&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;int,int&gt;M;</span><br><span class="line">map&lt;int,int&gt;::iterator it;</span><br><span class="line">int node_number,vertex_number;</span><br><span class="line">int u,v,cnt;</span><br><span class="line">int father[50];</span><br><span class="line">int find_father(int x)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span>(x!=father[x])</span><br><span class="line"> &#123;</span><br><span class="line">  x = father[x];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin&gt;&gt;node_number&gt;&gt;vertex_number;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  father[i] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=vertex_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">  father[v] = find_father(u);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  father[i] = find_father(father[i]);</span><br><span class="line">  <span class="keyword">if</span>(M[father[i]] == 0)</span><br><span class="line">  &#123;</span><br><span class="line">   cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  M[father[i]]++;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">for</span>(it = M.begin();it!=M.end();it++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;M[it-&gt;first]&lt;&lt;endl;//在题目要求中不需要输出map的键 </span><br><span class="line">  //这里的方法是对于迭代器使用的，不是map本身，请注意写法</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>题目描述<br>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 orz。</p>
<p>输入格式<br>第一行包含两个整数 N,M，表示该图共有 N 个结点和 M 条无向边。</p>
<p>接下来 M 行每行包含三个整数 X_i,Y_i,Z_i,表示有一条长度为 Z_i<br>的无向边连接结点 X_i,Y_i。</p>
<p>输出格式<br>如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 orz。</p>
<p>输入输出样例<br>输入 #1<br>4 5<br>1 2 2<br>1 3 2<br>1 4 3<br>2 3 4<br>3 4 3<br>输出 #1<br>7<br>说明/提示<br>数据规模：</p>
<p>对于 20\%20% 的数据，N≤5，M≤20。</p>
<p>对于 40\%40% 的数据，50N≤50，2500M≤2500。</p>
<p>对于 70\%70% 的数据，N≤500，4M≤10^4。</p>
<p>对于 100\%100% 的数据：1≤N≤5000,1≤M≤2×10^5。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int node_number,edge_number;</span><br><span class="line">struct Vertex</span><br><span class="line">&#123;</span><br><span class="line"> int u;</span><br><span class="line"> int v;</span><br><span class="line"> int w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Vertex&gt;edge;</span><br><span class="line">int father[5005];</span><br><span class="line">int u,v,w,cnt,cost;</span><br><span class="line">bool cmp(Vertex&amp;a,Vertex&amp;b)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line">int find_father(int x)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span>(x!=father[x])</span><br><span class="line"> &#123;</span><br><span class="line">  x = father[x];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()</span><br><span class="line">&#123;</span><br><span class="line"> int i;</span><br><span class="line"> <span class="keyword">for</span>(i = 0;i&lt;edge_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  int u = edge[i].u;</span><br><span class="line">  int v = edge[i].v;</span><br><span class="line">  int w = edge[i].w;</span><br><span class="line">  int u_father = find_father(u);</span><br><span class="line">  int v_father = find_father(v);</span><br><span class="line">  <span class="keyword">if</span>(u_father == v_father)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  father[v_father] = u_father;</span><br><span class="line">  cost = cost+w;</span><br><span class="line">  cnt++;</span><br><span class="line">  <span class="keyword">if</span>(cnt == node_number-1)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(i&gt;=edge_number)</span><br><span class="line"> &#123;</span><br><span class="line">  cost = -1;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin&gt;&gt;node_number&gt;&gt;edge_number;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  father[i] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> Vertex temp;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=edge_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin&gt;&gt;temp.u&gt;&gt;temp.v&gt;&gt;temp.w;</span><br><span class="line">  edge.push_back(temp);</span><br><span class="line"> &#125;</span><br><span class="line"> sort(edge.begin(),edge.end(),cmp);</span><br><span class="line"> kruskal();</span><br><span class="line"> <span class="keyword">if</span>(cost!=-1)</span><br><span class="line"> &#123;</span><br><span class="line">  cout&lt;&lt;cost&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">"orz"</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉排序树的建立和遍历"><a href="#二叉排序树的建立和遍历" class="headerlink" title="二叉排序树的建立和遍历"></a>二叉排序树的建立和遍历</h2><p>题目： 二叉排序树之父结点<br>问题描述<br>给你N个关键字值各不相同的节点，要求你按顺序插入一个初始为空树的二叉排序树中，每次插入后成功后，求相应的父亲节点的关键字值，如果没有父亲节点，则输出-1。<br>输入格式<br>测试数据有两行。第一行是一个数字N（N&lt;=100），表示待插入的节点数。第二行是N个互不相同的正整数，表示要顺序插入节点的关键字值，这些值不超过10^8。<br>输出格式<br>输出共N行，每次插入节点后，输出该节点对应的父亲节点的关键字值。<br>样例输入<br>5<br>2 5 1 3 4<br>样例输出<br>-1<br>2<br>2<br>5<br>3<br>样例说明<br>无。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int sav = -1, node_number;</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line"> Node* left = NULL;</span><br><span class="line"> Node* right = NULL;</span><br><span class="line"> int value;</span><br><span class="line">&#125;;</span><br><span class="line">Node* head = NULL;</span><br><span class="line">void insert_node(int value, Node*&amp; head)//一定要加上引用，否则不能更改指针的指向。</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (head == NULL)</span><br><span class="line"> &#123;</span><br><span class="line">  head = new Node;</span><br><span class="line">  head-&gt;value = value;</span><br><span class="line">  cout &lt;&lt; sav &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; head-&gt;value)</span><br><span class="line"> &#123;</span><br><span class="line">  sav = head-&gt;value;</span><br><span class="line">  insert_node(value, head-&gt;left);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; head-&gt;value)</span><br><span class="line"> &#123;</span><br><span class="line">  sav = head-&gt;value;</span><br><span class="line">  insert_node(value, head-&gt;right);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin &gt;&gt; node_number;</span><br><span class="line"> int v;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= node_number; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin &gt;&gt; v;</span><br><span class="line">  insert_node(v, head);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目： 二叉排序树的遍历<br>问题描述<br>输入一系列整数，建立二叉排序树，并进行前序，中序，后序遍历。<br>输入格式<br>输入第一行包括一个整数n(1&lt;=n&lt;=100)。<br>接下来的一行包括n个整数。<br>输出格式<br>将题目所给数据建立一个二叉排序树，并对二叉排序树进行前序、中序和后序遍历。<br>每种遍历结果输出一行。每行最后一个数据之后有一个空格。<br>输入中可能有重复元素，但是输出的二叉树遍历序列中重复元素不用输出。<br>样例输入<br>5<br>1 6 5 9 8<br>样例输出<br>1 6 5 9 8<br>1 5 6 8 9<br>5 8 9 6 1<br>样例说明<br>无。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include&lt;iterator&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line"> int value;</span><br><span class="line"> Node*left = NULL;</span><br><span class="line"> Node* right = NULL;</span><br><span class="line">&#125;;</span><br><span class="line">int node_number;</span><br><span class="line">Node*head = NULL;</span><br><span class="line">vector&lt;int&gt;preorder;</span><br><span class="line">vector&lt;int&gt;inorder;</span><br><span class="line">vector&lt;int&gt;postorder;</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">void insert_node(int value,Node*&amp;head)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(head == NULL)</span><br><span class="line"> &#123;</span><br><span class="line">  head = new Node;</span><br><span class="line">  head-&gt;value = value;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; head-&gt;value)</span><br><span class="line"> &#123;</span><br><span class="line">  insert_node(value,head-&gt;left);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; head-&gt;value)</span><br><span class="line"> &#123;</span><br><span class="line">  insert_node(value,head-&gt;right);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">void traverse(Node*aim)//注意遍历一定要专门写一个函数，不能在建树的时候遍历</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(aim!=NULL)</span><br><span class="line"> &#123;</span><br><span class="line">  preorder.push_back(aim-&gt;value);</span><br><span class="line">  traverse(aim-&gt;left);</span><br><span class="line">  inorder.push_back(aim-&gt;value);</span><br><span class="line">  traverse(aim-&gt;right);</span><br><span class="line">  postorder.push_back(aim-&gt;value);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin&gt;&gt;node_number;</span><br><span class="line"> int value;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin&gt;&gt;value;</span><br><span class="line">  insert_node(value,head);</span><br><span class="line"> &#125;</span><br><span class="line"> traverse(head);</span><br><span class="line"> <span class="keyword">for</span>(it = preorder.begin();it!=preorder.end();it++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout&lt;&lt;(*it)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line"> <span class="keyword">for</span>(it = inorder.begin();it!=inorder.end();it++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout&lt;&lt;(*it)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line"> <span class="keyword">for</span>(it = postorder.begin();it!=postorder.end();it++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout&lt;&lt;(*it)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目： 相同二叉排序树<br>问题描述<br>判断两序列是否为同一二叉排序树序列。<br>输入格式<br>数据有多组。每组数据第一行是一个数n，(1&lt;=n&lt;=20) 表示有n个需要判断，n=0 的时候输入结束。接下去一行是一个序列，序列长度小于10，包含(0~9)的数字，没有重复数字，根据这个序列可以构造出一颗二叉排序树。接下去的n行有n个序列，每个序列格式跟第一个序列一样，请判断这两个序列是否能组成同一颗二叉排序树。<br>输出格式<br>如果二叉排序树相同则输出YES，否则输出NO<br>样例输入<br>2<br>567432<br>543267<br>576342<br>0<br>样例输出<br>YES<br>NO<br>样例说明<br>无</p>
<p>1、建树，和上面两个题目相同。<br>2、比较。下面先贴出递归的比较的代码。可以根据返回值来确定两个树是否相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int compare(BiTree t1, BiTree t2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == NULL &amp;&amp; t2 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t1 == NULL || t2 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = 0;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t1-&gt;data != t2-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = 0;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> compare(t1-&gt;l, t2-&gt;l) &amp;&amp; compare(t1-&gt;r, t2-&gt;r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码,比较啰嗦，只看上面的关键代码就可以。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node* l, * r;</span><br><span class="line">&#125;BiTode, * BiTree;</span><br><span class="line">BiTree t1, t2;</span><br><span class="line">int flag;</span><br><span class="line">BiTree insert(BiTree t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        t = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">        t-&gt;data = x;</span><br><span class="line">        t-&gt;l = NULL;</span><br><span class="line">        t-&gt;r = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; t-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        t-&gt;l = insert(t-&gt;l, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t-&gt;r = insert(t-&gt;r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">BiTree creat(char a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    BiTree t = NULL;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        t = insert(t, a[j] - <span class="string">'0'</span>);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">int compare(BiTree t1, BiTree t2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == NULL &amp;&amp; t2 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t1 == NULL || t2 == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = 0;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t1-&gt;data != t2-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = 0;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> compare(t1-&gt;l, t2-&gt;l) &amp;&amp; compare(t1-&gt;r, t2-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, len;</span><br><span class="line">    char a[11], b[11];</span><br><span class="line">    //<span class="keyword">while</span> (scanf(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n)</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //scanf(<span class="string">"%s"</span>, a);</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        len = strlen(a);//strlen的参数只能是char 类型</span><br><span class="line">        t1 = creat(a, len);</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            //scanf(<span class="string">"%s"</span>, b);</span><br><span class="line">            cin &gt;&gt; b;</span><br><span class="line">            t2 = creat(b, len);</span><br><span class="line">            flag = 1;</span><br><span class="line">            compare(t1, t2);</span><br><span class="line">            <span class="keyword">if</span> (flag == 1)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">## 并查集+unique 判断无向连通子图的个数</span></span><br><span class="line"></span><br><span class="line">高铁网络</span><br><span class="line">描述：</span><br><span class="line">国家建设高铁网络，网络由一些连接城市的高铁线路构成。现有高铁建设情况可列为一张统计表，表中列出了每一条高铁线路直接连接的两个城市。国家的建设目标是全国每两个城市之间都可以实现高铁交通（但不一定有直接的高铁线路相连，只要能间接通过高铁线路可达即可）。问最少还要建设多少条高铁线路？</span><br><span class="line">输入说明：</span><br><span class="line">测试用例的第1行给出两个正整数，分别是城市数目N(&lt;1000)和现有高铁线路数目M。随后的M行对应M条高铁线路，每行给出一对正整数，分别是该条高铁线路直接连接的两个城市的编号。为简单起见，城市从1到N编号。</span><br><span class="line">输出说明：</span><br><span class="line">在一行上输出最少还需要建设多少条高铁线路。</span><br><span class="line">输入样例：</span><br><span class="line">9 8</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">5 7</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">8 9</span><br><span class="line">输出样例：</span><br><span class="line">2</span><br><span class="line">实现提示：</span><br><span class="line">该问题实质为求连通分量的个数减一，可用深度优先或广度优先搜索求解，也可用MFSet求解。</span><br><span class="line"></span><br><span class="line">在unique之前一定要记得先sort。</span><br><span class="line"></span><br><span class="line">```Bash</span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int city_number,road_number;</span><br><span class="line">int father[1005];</span><br><span class="line">int find_father(int x)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span>(x!=father[x])</span><br><span class="line"> &#123;</span><br><span class="line">  x = father[x];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin&gt;&gt;city_number&gt;&gt;road_number;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=city_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  father[i] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> int u,v;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=road_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">  int u_father = find_father(u);</span><br><span class="line">  int v_father = find_father(v);</span><br><span class="line">  <span class="keyword">if</span>(u_father!= v_father)</span><br><span class="line">  &#123;</span><br><span class="line">   father[v_father] = u_father;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=city_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  father[i] = find_father(father[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> sort(&amp;father[1],&amp;father[city_number+1]);</span><br><span class="line"> int *tail = unique(&amp;father[1],&amp;father[city_number+1]);</span><br><span class="line"> int number = tail-&amp;father[1];</span><br><span class="line"> number--;</span><br><span class="line"> cout&lt;&lt;number&lt;&lt;endl;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>题目8：关键路径<br>问题描述<br>计算AOE-网中关键路径的长度。<br>输入格式<br> 输入数据第一行是一个正整数，表示图中的顶点个数n（顶点将分别按0，1，…，n-1进行编号），顶点数不超过100，其中0为源点，n-1为汇点。之后的n行每行都包含n个整数，为AOE-网的邻接矩阵，其中0表示两个顶点间无直接可达的弧，大于0的整数表示活动持续的时间。<br>输出格式<br>输出AOE-网中关键路径的长度，如果网中有环，则输出“NO”。<br>样例输入<br> 9<br>0 6 4 5 0 0 0 0 0<br>0 0 0 0 1 0 0 0 0<br>0 0 0 0 1 0 0 0 0<br>0 0 0 0 0 2 0 0 0<br>0 0 0 0 0 0 9 7 0<br>0 0 0 0 0 0 0 4 0<br>0 0 0 0 0 0 0 0 2<br>0 0 0 0 0 0 0 0 4<br>0 0 0 0 0 0 0 0 0<br>样例输出<br>18</p>
<p>输出说明：如果网中有环，则示例输出如下：<br>NO</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">//拓扑序，最早开始时间</span><br><span class="line">//逆拓扑序，最迟开始时间</span><br><span class="line">//二者相等即为关键节点</span><br><span class="line">//关键节点连接的路径即为关键路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 1 &lt;&lt; 31;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">bool hav_cy = 0;</span><br><span class="line">int G[110][110];//图的邻接表</span><br><span class="line">int es[110];//每个节点的最早开始时间数组</span><br><span class="line">int ls[110];//每个节点的最晚开始时间数组</span><br><span class="line">bool used[110];//DFS的标记数组</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">    fill(es, es + n, 0);</span><br><span class="line">    fill(ls, ls + n, INF);</span><br><span class="line">    fill(used, used + n, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void find_es(int now) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now == n) <span class="built_in">return</span>;</span><br><span class="line">    //如果这个节点已经是图的最后一个节点，则结束DFS</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; ++i) &#123;//循环节点位置，寻找更新es的目标</span><br><span class="line">        <span class="keyword">if</span> (G[now][i]) &#123;//如果now和i节点连通</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;//如果在循环过程中找到了已经搜索过的节点，则这个图中存在环，DFS结束</span><br><span class="line">                hav_cy = 1;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                es[i] = max(es[i], es[now] + G[now][i]);</span><br><span class="line">                //更新i项目的最晚开始时间，为所有在它之前的项目完成时间取最大值</span><br><span class="line">                used[i] = <span class="literal">true</span>;//将i项目标记为已访问</span><br><span class="line">                find_es(i);//i项目为DFS的下一个目标，进一步更新路径</span><br><span class="line">                used[i] = <span class="literal">false</span>;//回溯</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void find_ls(int now) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now == -1) <span class="built_in">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[i][now]) &#123;</span><br><span class="line">            ls[i] = min(ls[i], ls[now] - G[i][now]);</span><br><span class="line">            find_ls(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    scanf(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            scanf(<span class="string">"%d"</span>, &amp;G[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    find_es(0);</span><br><span class="line">    <span class="keyword">if</span> (hav_cy) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        fill(ls, ls + n, es[n - 1]);</span><br><span class="line">        find_ls(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, es[n - 1]);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我自己的代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int es[105],ls[105];</span><br><span class="line">int node_number;</span><br><span class="line">int map[105][105];</span><br><span class="line">int has_cl = 0;</span><br><span class="line">int vis[105];</span><br><span class="line">void find_es(int x)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(x == node_number)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(int i = 0;i&lt;node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(map[x][i])</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(vis[i] == 1)</span><br><span class="line">   &#123;</span><br><span class="line">    has_cl = 1;</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">    es[i] = max(es[i],es[x]+map[x][i]);//将经过x点的路径长度和es[i]数组内的数据长度作比较 </span><br><span class="line">    vis[i] = 1;</span><br><span class="line">    find_es(i);</span><br><span class="line">    vis[i] = 0;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">void find_ls(int x)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(x == -1)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(int i = 0;i&lt;node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(map[i][x])</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(vis[i] == 0)</span><br><span class="line">   &#123;</span><br><span class="line">    ls[i] = min(ls[i],ls[x]-map[i][x]);</span><br><span class="line">    vis[i] = 1;</span><br><span class="line">    find_ls(i);</span><br><span class="line">    vis[i] = 0;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin&gt;&gt;node_number;</span><br><span class="line"> <span class="keyword">for</span>(int i = 0;i&lt;node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span>(int j = 0;j&lt;node_number;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   cin&gt;&gt;map[i][j]; </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> find_es(0);</span><br><span class="line"> <span class="keyword">if</span>(has_cl == 1)</span><br><span class="line"> &#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">"NO"</span>&lt;&lt;endl;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line"> &#125;</span><br><span class="line"> fill(&amp;ls[0],&amp;ls[node_number],es[node_number-1]);</span><br><span class="line"> find_ls(node_number-1);</span><br><span class="line"> cout&lt;&lt;ls[node_number-1]&lt;&lt;endl;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断有向图中是否有环"><a href="#判断有向图中是否有环" class="headerlink" title="判断有向图中是否有环"></a>判断有向图中是否有环</h2><p>题目：判断有向图中是否有环<br>问题描述<br>判断有向图中是否有环。<br>输入格式<br> 输入数据第一行是一个正整数，表示n个有向图，其余数据分成n组，每组第一个为一个整数，表示图中的顶点个数n，顶点数不超过100，之后为有向图的邻接矩阵。<br>输出格式<br>输出结果为一行，如果有环，则输出1，如果无环，则输出0。按顺序输出这n个有向图的判断结果，前后结果的输出不加空格。<br>样例输入<br>3<br>2<br>0 1<br>0 0<br>3<br>0 1 1<br>0 0 0<br>0 0 0<br> 4<br>0 1 0 0<br>0 0 0 1<br>0 0 0 1<br>1 0 0 0<br>样例输出<br>001</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int map[105][105];</span><br><span class="line">int node_number;</span><br><span class="line">int <span class="built_in">times</span>;</span><br><span class="line">int vis[105];</span><br><span class="line">int has_cl;</span><br><span class="line">void find_cl(int start)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(start == node_number)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(int i = 0;i&lt;node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(map[start][i])</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(vis[i])</span><br><span class="line">   &#123;</span><br><span class="line">    has_cl = 1;</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">    vis[i] = 1;</span><br><span class="line">    find_cl(i);</span><br><span class="line">    vis[i] = 0;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin&gt;&gt;<span class="built_in">times</span>;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=<span class="built_in">times</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  has_cl = 0;</span><br><span class="line">  cin&gt;&gt;node_number;</span><br><span class="line">  <span class="keyword">for</span>(int x = 0;x&lt;node_number;x++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">for</span>(int y = 0;y&lt;node_number;y++)</span><br><span class="line">   &#123;</span><br><span class="line">    cin&gt;&gt;map[x][y];</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(int x = 0;x&lt;node_number;x++)</span><br><span class="line">  &#123;</span><br><span class="line">   find_cl(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(has_cl)</span><br><span class="line">  &#123;</span><br><span class="line">   cout&lt;&lt;<span class="string">"YES\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   cout&lt;&lt;<span class="string">"NO\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h2><p>题目：图的广度优先遍历<br>问题描述<br>已知无向图的邻接矩阵，以该矩阵为基础，给出广度优先搜索遍历序列，并且给出该无向图的连通分量的个数。在遍历时，当有多个点可选时，优先选择编号小的顶点。（即从顶点1开始进行遍历）<br>输入格式<br> 第一行是1个正整数，为顶点个数n（n&lt;100），顶点编号依次为1，2，…，n。后面是邻接矩阵，n行n列。<br>输出格式<br>共2行。第一行输出为无向图的广度优先搜索遍历序列，输出为顶点编号，顶点编号之间用空格隔开；第二行为无向图的连通分量的个数。<br>样例输入<br> 6<br>0 1 0 0 0 0<br>1 0 0 0 1 0<br>0 0 0 1 0 0<br>0 0 1 0 0 0<br>0 1 0 0 0 1<br>0 0 0 0 1 0<br>样例输出<br> 1 2 5 6 3 4<br>2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int map[105][105];</span><br><span class="line">queue&lt;int&gt; que;</span><br><span class="line">int node_number;</span><br><span class="line">int record[105];</span><br><span class="line">int cnt;</span><br><span class="line">void BFS(int start, int color)</span><br><span class="line">&#123;</span><br><span class="line"> int temp;</span><br><span class="line"> que.push(start);</span><br><span class="line"> record[start] = color;</span><br><span class="line"> <span class="keyword">while</span> (!que.empty())</span><br><span class="line"> &#123;</span><br><span class="line">  temp = que.front();</span><br><span class="line">  cout &lt;&lt; temp &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  que.pop();</span><br><span class="line">  <span class="keyword">for</span> (int i = 1; i &lt;= node_number; i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span> (map[temp][i]&amp;&amp;record[i] == 0)</span><br><span class="line">   &#123;</span><br><span class="line">    record[i] = color;</span><br><span class="line">    que.push(i);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin &gt;&gt; node_number;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= node_number; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span> (int j = 1; j &lt;= node_number; j++)</span><br><span class="line">  &#123;</span><br><span class="line">   cin &gt;&gt; map[i][j];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (int i = 1; i &lt;= node_number; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span> (record[i] == 0)</span><br><span class="line">  &#123;</span><br><span class="line">   BFS(i, ++cnt);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; <span class="string">"\n"</span> &lt;&lt; cnt &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h2><p>题目：图的深度优先遍历<br>问题描述<br>已知无向图的邻接矩阵，以该矩阵为基础，给出深度优先搜索遍历序列，并且给出该无向图的连通分量的个数。在遍历时，当有多个点可选时，优先选择编号小的顶点。（即从顶点1开始进行遍历）<br>输入格式<br> 第一行是1个正整数，为顶点个数n（n&lt;100），顶点编号依次为1，2，…，n。后面是邻接矩阵，n行n列。<br>输出格式<br>共2行。第一行输出为无向图的深度优先搜索遍历序列，输出为顶点编号，顶点编号之间用空格隔开；第二行为无向图的连通分量的个数。<br>样例输入<br> 6<br>0 1 0 0 0 0<br>1 0 0 0 1 0<br>0 0 0 1 0 0<br>0 0 1 0 0 0<br>0 1 0 0 0 1<br>0 0 0 0 1 0<br>样例输出<br> 1 2 5 6 3 4<br>2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int map[105][105];</span><br><span class="line">int node_number,cnt;</span><br><span class="line">int record[105];</span><br><span class="line">void DFS(int color,int now)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(now == node_number+1)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> record[now] = color;</span><br><span class="line"> cout&lt;&lt;now&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(map[now][i]&amp;&amp;record[i] == 0)</span><br><span class="line">  &#123;</span><br><span class="line">   DFS(color,i);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin&gt;&gt;node_number;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span>(int j = 1;j&lt;=node_number;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   cin&gt;&gt;map[i][j];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(record[i] == 0)</span><br><span class="line">  &#123;</span><br><span class="line">   DFS(++cnt,i);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;<span class="string">"\n"</span>&lt;&lt;cnt&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><p>题目描述<br>给定一个 n 个点，m 条有向边的带非负权图，请你计算从 s 出发，到每个点的距离。</p>
<p>数据保证你能从 ss 出发到任意点。</p>
<p>输入格式<br>第一行为三个正整数 n, m, sn,m,s。 第二行起 mm 行，每行三个非负整数 u_i, v_i, w_i，表示从 u_i到 v_i有一条权值为 w_i的有向边。</p>
<p>输出格式<br>输出一行 nn 个空格分隔的非负整数，表示 ss 到每个点的距离。</p>
<p>输入输出样例<br>输入 #1复制<br>4 6 1<br>1 2 2<br>2 3 2<br>2 4 1<br>1 3 5<br>3 4 3<br>1 4 4<br>输出 #1复制<br>0 2 4 3<br>说明/提示<br>样例解释请参考 数据随机的模板题。</p>
<p>1≤n≤10^5；<br>1≤m≤2×10^5;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#include&lt;functional&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;climits&gt; </span></span><br><span class="line">using namespace std;</span><br><span class="line">int edge_number,node_number,start;</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line"> int cost;</span><br><span class="line"> int to;</span><br><span class="line">&#125;;</span><br><span class="line">typedef pair&lt;int,int&gt; P;//pair在优先队列中是以first为关键字排序的</span><br><span class="line">vector&lt;P&gt;edge[100005];//相当于用一个二维动态数组把所有以某个固定点为起点的边存在一起，便于遍历。</span><br><span class="line">int dis[100005];</span><br><span class="line">int vis[100005];//一定要有vis数组，否则会出现死循环，MLE。</span><br><span class="line">priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;</span><br><span class="line">void DJ(int start)</span><br><span class="line">&#123;</span><br><span class="line"> fill(&amp;dis[1],&amp;dis[node_number+1],INT_MAX);</span><br><span class="line"> P elem;</span><br><span class="line"> elem.first = 0;</span><br><span class="line"> elem.second = start;</span><br><span class="line"> dis[start] = 0;//不能忘记初始化start位置的dis，否则会导致图不连通，也不能在这里就修改start的vis,这将导致在进入<span class="keyword">while</span>循环后直接被<span class="built_in">continue</span>掉</span><br><span class="line"> que.push(elem);</span><br><span class="line"> int v,w;</span><br><span class="line"> <span class="keyword">while</span>(!que.empty())</span><br><span class="line"> &#123;</span><br><span class="line">  elem = que.top();</span><br><span class="line">  que.pop();</span><br><span class="line">  w = elem.first;</span><br><span class="line">  v = elem.second;</span><br><span class="line">  <span class="keyword">if</span>(vis[v])</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[v] = 1;</span><br><span class="line">  <span class="keyword">if</span>(dis[v]&lt;w)//别忘记加上这一句话，节省运行时间</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  int len = edge[v].size();</span><br><span class="line">  P next;</span><br><span class="line">  <span class="keyword">for</span>(int i = 0;i&lt;len;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   next.first = edge[v][i].first;</span><br><span class="line">   next.second = edge[v][i].second;</span><br><span class="line">   <span class="keyword">if</span>(dis[next.second] &gt; dis[v]+next.first)//是next的cost不是v的cost</span><br><span class="line">   &#123;</span><br><span class="line">    dis[next.second] = dis[v]+next.first;</span><br><span class="line">    next.first = dis[next.second];//入队列的是dis[next.second]而不是next.second的cost</span><br><span class="line">    que.push(next);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int u,v,w;</span><br><span class="line"> P temp;</span><br><span class="line"> cin&gt;&gt;node_number&gt;&gt;edge_number&gt;&gt;start;</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=edge_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">  temp.first = w;</span><br><span class="line">  temp.second = v;</span><br><span class="line">  edge[u].push_back(temp);</span><br><span class="line"> &#125;</span><br><span class="line"> DJ(start);</span><br><span class="line"> <span class="keyword">for</span>(int i = 1;i&lt;=node_number;i++)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dis[i] == INT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">     dis[i] = 2e31 - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  cout&lt;&lt;dis[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多源最短路径"><a href="#多源最短路径" class="headerlink" title="多源最短路径"></a>多源最短路径</h2><p>Floyd算法<br>将所有节点的距离都存在一个数组里，由于要枚举所有的两两组合以及每一个组合的“中转点”，再进行松弛操作<br>在使用前要对dis数组初始化为INT_MAX.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int k = 1;k&lt;=vertexnum;k++&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = 1;i&lt;=vertexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = 1;j&lt;=vertexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[i][j] = min(dis[i][j],dis[i][k]+dis[k][j]);//松弛操作，即更新每两个点之间的距离</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全二叉树的子树"><a href="#完全二叉树的子树" class="headerlink" title="完全二叉树的子树"></a>完全二叉树的子树</h2><p>题目：完全二叉树的子树<br>问题描述<br>对一棵完全二叉树，采用自上而下、自左往右的方式从1开始编号，我们已知这个二叉树的最后一个结点是n，现在的问题是结点m所在的子树一共包括多少个结点？<br>输入格式<br> 输入数据包括多行，每行给出一组测试数据，包括两个整数m，n (1 &lt;= m &lt;= n &lt;= 1000000000)。0 0表示输入结束。<br>输出格式<br> 对于每一组测试数据，输出一行，该行包含一个整数，给出结点m所在子树中包括的结点的数目。<br>样例输入<br> 3 12<br> 0 0<br>样例输出<br> 4</p>
<p>若编号为i的结点有左孩子结点,则左孩子结点的编号为2i；若编号为i的结点有右孩子结点,则右孩子结点的编号为(2i+1)。<br>当2i&gt;n，则结点i无左孩子，无左孩子则结点i为叶子结点；当2i+1&gt;n，则结点无右孩子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int aim_node,node_number;</span><br><span class="line">int cnt;</span><br><span class="line">void find_child(int x)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(x &gt; node_number||x&lt;1&gt;)//注意这里是两个条件，保证x在1~node_number之间即可</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cnt++;</span><br><span class="line"> find_child(2*x);//左孩子是2*x而不是2*x-1，一个满二叉树的左右孩子的编号应该是相邻的</span><br><span class="line"> find_child(2*x+1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span>(1)</span><br><span class="line"> &#123;</span><br><span class="line">  cnt = 0;</span><br><span class="line">  cin&gt;&gt;aim_node&gt;&gt;node_number;</span><br><span class="line">  <span class="keyword">if</span>(aim_node==0&amp;&amp;node_number == 0)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  find_child(aim_node);</span><br><span class="line">  cout&lt;&lt;cnt&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展先序转中序"><a href="#扩展先序转中序" class="headerlink" title="扩展先序转中序"></a>扩展先序转中序</h2><p>题目：二叉树扩展先序遍历转中序遍历<br>问题描述<br>编一个程序，读入用户输入的一串扩展先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的扩展先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。<br>输入格式<br> 输入包括1行字符串，长度不超过100。<br>输出格式<br> 输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。每个输出结果占一行。<br>样例输入<br> abc##de#g##f###<br>样例输出<br> c b e g d f a<br>样例说明<br>根据给定的扩展先序遍历序列，建立对应的二叉树，然后对所得的二叉树进行中序遍历输出结果即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line"> char value;</span><br><span class="line"> Node*left = NULL;</span><br><span class="line"> Node*right = NULL;</span><br><span class="line">&#125;;</span><br><span class="line">Node*head = NULL;</span><br><span class="line">char input;</span><br><span class="line">void set_tree(Node*&amp;head)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(!(cin&gt;&gt;input))</span><br><span class="line"> &#123;</span><br><span class="line">  head = NULL;</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(input == <span class="string">'#'</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  head = NULL;</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> head = new Node;</span><br><span class="line"> head-&gt;value = input;</span><br><span class="line"> set_tree(head-&gt;left);</span><br><span class="line"> set_tree(head-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">void inorder(Node*head)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(head == NULL)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> inorder(head-&gt;left);</span><br><span class="line"> cout&lt;&lt;head-&gt;value;</span><br><span class="line"> inorder(head-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> set_tree(head);</span><br><span class="line"> inorder(head);</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#include&lt;functional&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br><span class="line">int n,ans=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"> <span class="keyword">while</span>(n--)</span><br><span class="line"> &#123;</span><br><span class="line">  int t;</span><br><span class="line">  scanf(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">  q.push(t);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span>(1)</span><br><span class="line"> &#123;</span><br><span class="line">  int a=q.top();</span><br><span class="line">  q.pop();</span><br><span class="line">  <span class="keyword">if</span>(q.empty())</span><br><span class="line">   <span class="built_in">break</span>;</span><br><span class="line">  int b=q.top();</span><br><span class="line">  q.pop();</span><br><span class="line">  ans+=a+b;</span><br><span class="line">  q.push(a+b);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈夫曼树的wpl就是所有非叶子结点的权之和<br>这样子就不用专门去求路径长度了<br>直接遍历一遍找出非叶子结点相加就好了</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%94%E8%AE%B0/" rel="prev" title="数据结构笔记">
      <i class="fa fa-chevron-left"></i> 数据结构笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/14/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%AA%E8%AE%BA/" rel="next" title="计算机系统概述">
      计算机系统概述 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#直接插入排序"><span class="nav-number">1.</span> <span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序"><span class="nav-number">2.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-number">3.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序"><span class="nav-number">4.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序"><span class="nav-number">5.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找"><span class="nav-number">6.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉排序树"><span class="nav-number">7.</span> <span class="nav-text">二叉排序树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表"><span class="nav-number">8.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无向连通子图"><span class="nav-number">9.</span> <span class="nav-text">无向连通子图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小生成树"><span class="nav-number">10.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉排序树的建立和遍历"><span class="nav-number">11.</span> <span class="nav-text">二叉排序树的建立和遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键路径"><span class="nav-number">12.</span> <span class="nav-text">关键路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断有向图中是否有环"><span class="nav-number">13.</span> <span class="nav-text">判断有向图中是否有环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的广度优先遍历"><span class="nav-number">14.</span> <span class="nav-text">图的广度优先遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的深度优先遍历"><span class="nav-number">15.</span> <span class="nav-text">图的深度优先遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单源最短路径"><span class="nav-number">16.</span> <span class="nav-text">单源最短路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多源最短路径"><span class="nav-number">17.</span> <span class="nav-text">多源最短路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完全二叉树的子树"><span class="nav-number">18.</span> <span class="nav-text">完全二叉树的子树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展先序转中序"><span class="nav-number">19.</span> <span class="nav-text">扩展先序转中序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈夫曼树"><span class="nav-number">20.</span> <span class="nav-text">哈夫曼树</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Monica</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Monica</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
